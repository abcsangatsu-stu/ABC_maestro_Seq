<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ABC Maestro SEQ v5</title>
<script src="https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js"></script>
<style>
  :root {
    --bg-color: #1a1a2e;
    --color-ch0: #e11d48;
    --color-ch1: #3b82f6;
    --color-ch2: #22c55e;
    --panel-bg: #1e1e38;
    --step-bg: #2a2a4a;
    --input-bg: #222238;
    --border: #444;
    --border-dim: #333;
    --text: #eee;
    --text-dim: #aaa;
    --text-muted: #666;
    --canvas-bg: #12122a;
    --freq-color: #f0c040;
    --vol-color: #8a8a9a;
    --pan-color: #6ee7b7;
    --accent: #4cc9f0;
    --accent-text: #111;
    --accent-active: #f72585;
    --btn-play: #4cc9f0;

    /* RT channel */
    --color-rt: #06b6d4;
    --btn-song: #22c55e;
    --btn-stop: #2a2a4a;
    --btn-clear: #2a2a4a;
    --btn-export: #a78bfa;
    --btn-save: #38bdf8;
    --btn-load: #2a2a4a;
    --btn-random: #fb923c;
    --btn-settings: #64748b;
    --btn-vary: #f472b6;
    --btn-score: #2dd4bf;
    --btn-wav: #facc15;
    --btn-mp3: #f87171;
    --btn-text: #111;
  }
  * { box-sizing: border-box; margin: 0; padding: 0; }
  body { background: var(--bg-color); color: var(--text); font-family: 'Courier New', monospace; padding: 20px; }
  h1 { text-align: center; font-size: 1.1em; color: var(--accent); letter-spacing: 3px; margin-bottom: 4px; }
  .subtitle { text-align: center; font-size: 0.7em; color: var(--text-muted); margin-bottom: 20px; letter-spacing: 1px; }

  /* Global controls */
  .controls { display: flex; gap: 12px; align-items: flex-end; justify-content: center; flex-wrap: wrap; margin-bottom: 18px; }
  .ctrl-group { display: flex; flex-direction: column; gap: 4px; }
  .controls label { font-size: 0.75em; color: var(--text-dim); }
  .controls input[type=number], .controls select {
    background: var(--step-bg); border: 1px solid var(--border); color: var(--text);
    padding: 5px 8px; border-radius: 4px; font-size: 0.9em; width: 70px;
  }

  /* Song lane */
  .song-section {
    background: var(--panel-bg); border-radius: 8px; padding: 8px 10px;
    border: 1px solid var(--step-bg); margin-bottom: 10px;
  }
  .song-section-label { font-size: 0.75em; color: var(--text-muted); margin-bottom: 6px; letter-spacing: 1px; }
  .song-lane { display: flex; align-items: center; gap: 4px; flex-wrap: wrap; min-height: 58px; }
  .song-cell {
    width: 78px; height: 68px; border-radius: 5px;
    border: 1px solid var(--border); cursor: grab;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    gap: 2px; transition: background 0.08s; user-select: none; position: relative;
    background: var(--step-bg);
  }
  .song-cell.drag-source { opacity: 0.3; }
  .song-cell.drag-over-left { border-left: 3px solid var(--freq-color); }
  .song-cell.drag-over-right { border-right: 3px solid var(--freq-color); }
  .song-cell .sc-delete {
    position: absolute; top: -5px; right: -5px; width: 15px; height: 15px;
    border-radius: 50%; background: #e11d48; color: #fff; font-size: 9px;
    display: none; align-items: center; justify-content: center; cursor: pointer;
    line-height: 1; border: 1px solid #fff3; z-index: 2;
  }
  .song-cell:hover .sc-delete { display: flex; }
  /* Section color bands */
  .song-cell.sec-red    { border-bottom: 3px solid #e11d48; }
  .song-cell.sec-orange { border-bottom: 3px solid #f97316; }
  .song-cell.sec-yellow { border-bottom: 3px solid #eab308; }
  .song-cell.sec-green  { border-bottom: 3px solid #22c55e; }
  .song-cell.sec-blue   { border-bottom: 3px solid #3b82f6; }
  .song-cell.sec-purple { border-bottom: 3px solid #a855f7; }
  .rt-song-cell { border-color: color-mix(in srgb, var(--color-rt) 40%, var(--border)); }
  .rt-song-cell.sec-red    { border-bottom-color: #e11d48; }
  .rt-song-cell.sec-orange { border-bottom-color: #f97316; }
  .rt-song-cell.sec-yellow { border-bottom-color: #eab308; }
  .rt-song-cell.sec-green  { border-bottom-color: #22c55e; }
  .rt-song-cell.sec-blue   { border-bottom-color: #3b82f6; }
  .rt-song-cell.sec-purple { border-bottom-color: #a855f7; }
  .song-cell.active { outline: 2px solid var(--accent); outline-offset: 1px; z-index: 1; }
  .song-cell.song-playing { box-shadow: inset 0 0 0 3px #ffd700; background: color-mix(in srgb, #ffd700 18%, var(--step-bg)); }
  .song-cell.song-playing.active { outline: 2px solid var(--accent); box-shadow: inset 0 0 0 3px #ffd700; }
  .song-cell .sc-name { font-size: 1.1em; font-weight: bold; color: var(--accent-text); line-height: 1; }
  .song-cell .sc-repeat-wrap { display: flex; align-items: center; gap: 2px; }
  .song-cell .sc-repeat-label { font-size: 0.6em; color: color-mix(in srgb, var(--accent-text) 50%, transparent); }
  .song-cell .sc-repeat-input {
    width: 32px; background: color-mix(in srgb, var(--accent-text) 10%, transparent); border: 1px solid color-mix(in srgb, var(--accent-text) 20%, transparent);
    color: var(--accent-text); padding: 2px 3px; border-radius: 3px; font-size: 1.3em;
    text-align: center; font-family: monospace; font-weight: bold;
  }
  .song-add {
    width: 36px; height: 68px; border-radius: 5px;
    border: 1px dashed var(--border); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    color: var(--text-muted); font-size: 1.1em; transition: all 0.15s;
  }
  .song-add:hover { background: var(--step-bg); color: var(--text-dim); border-color: var(--border); }
  .song-cell.song-playhead::after {
    content: ''; position: absolute; top: -4px; left: 50%; transform: translateX(-50%);
    width: 0; height: 0; border-left: 6px solid transparent; border-right: 6px solid transparent;
    border-top: 6px solid #3b82f6; z-index: 3;
  }

  /* Pattern pool */
  .pattern-pool {
    display: flex; align-items: center; gap: 4px; flex-wrap: wrap;
    padding: 6px 8px; margin-top: 4px;
    border: 1px dashed var(--border); border-radius: 6px;
    min-height: 36px; background: color-mix(in srgb, var(--step-bg) 50%, transparent);
  }
  .pattern-pool-label {
    font-size: 0.6em; color: var(--text-muted); letter-spacing: 1px;
    writing-mode: vertical-lr; margin-right: 2px;
  }
  .pool-cell {
    padding: 4px 10px; border-radius: 4px; border: 1px solid var(--border);
    background: var(--panel-bg); cursor: grab; font-size: 0.85em; font-weight: bold;
    color: var(--text); transition: all 0.1s; user-select: none; position: relative;
  }
  .pool-cell:hover { background: var(--step-bg); border-color: var(--text-muted); }
  .pool-cell.drag-over { outline: 2px solid var(--freq-color); }
  .pool-del-btn {
    position: absolute; top: -6px; right: -6px;
    background: #e11d48; color: #fff; border-radius: 50%;
    width: 14px; height: 14px; font-size: 10px; line-height: 14px;
    text-align: center; cursor: pointer; display: none;
  }
  .pool-cell:hover .pool-del-btn { display: block; }

  /* Pattern bar */
  .pattern-bar {
    display: flex; align-items: center; gap: 8px; margin-bottom: 10px; flex-wrap: wrap;
  }
  .pattern-bar label { font-size: 0.75em; color: var(--text-dim); }
  .pat-select {
    background: var(--step-bg); border: 1px solid var(--border); color: var(--text);
    padding: 4px 8px; border-radius: 4px; font-size: 0.85em; font-family: monospace;
    cursor: pointer;
  }
  .pat-btn {
    background: var(--step-bg); border: 1px solid var(--border); color: var(--text-dim);
    padding: 3px 10px; border-radius: 4px; font-size: 0.72em; cursor: pointer;
    font-family: monospace; letter-spacing: 0.5px; transition: all 0.15s;
  }
  .pat-btn:hover { background: var(--border); color: var(--text); }

  /* Channel blocks */
  .ch-blocks { display: flex; flex-direction: column; gap: 8px; margin-bottom: 16px; }
  .ch-block { background: var(--panel-bg); border-radius: 8px; padding: 8px 10px; border: 1px solid var(--step-bg); }

  /* Block A: header row */
  .ch-header { display: flex; align-items: center; gap: 10px; margin-bottom: 5px; flex-wrap: wrap; }
  .ch-name { font-size: 0.85em; min-width: 38px; font-weight: bold; }
  .ch-name.c0 { color: var(--color-ch0); }
  .ch-name.c1 { color: var(--color-ch1); }
  .ch-name.c2 { color: var(--color-ch2); }
  .ch-name.crt { color: var(--color-rt); }
  .midi-cfg { display: flex; gap: 6px; align-items: center; flex-wrap: wrap; }
  .midi-cfg label { font-size: 0.65em; color: var(--text-muted); }
  .midi-cfg input { width: 46px; background: var(--input-bg); border: 1px solid var(--border-dim); color: var(--text-dim); padding: 2px 4px; border-radius: 4px; font-size: 0.72em; text-align: center; }
  .steps-ctrl { display: flex; align-items: center; gap: 3px; }
  .sc-btn { width: 20px; height: 20px; background: var(--step-bg); border: 1px solid var(--border); color: var(--text-dim); border-radius: 4px; cursor: pointer; font-size: 0.85em; line-height: 1; }
  .sc-btn:hover { background: var(--border); }
  .sc-input { width: 50px; background: var(--input-bg); border: 1px solid var(--border); color: var(--text); padding: 2px 3px; border-radius: 4px; font-size: 0.75em; text-align: center; }

  /* Block B: wave controls row */
  .ch-wave-row {
    display: flex; align-items: center; gap: 6px;
    margin-bottom: 5px; flex-wrap: wrap;
    padding: 4px 6px; background: var(--canvas-bg); border-radius: 5px;
  }
  .wave-preview { border: 1px solid var(--step-bg); border-radius: 4px; flex-shrink: 0; }
  .wave-sel {
    background: var(--input-bg); border: 1px solid var(--border); color: var(--text);
    padding: 3px 5px; border-radius: 4px; font-size: 0.72em;
    font-family: monospace; cursor: pointer;
  }
  .wave-sel:focus { border-color: var(--text-muted); outline: none; }
  .dur-sel { width: 54px; }
  .sel-label { font-size: 0.58em; color: var(--border); min-width: 44px; text-align: center; }
  .sel-label.active { color: var(--freq-color); font-weight: bold; }
  .audio-mode-btn {
    padding: 1px 5px; border-radius: 3px; font-size: 0.5em; cursor: pointer;
    font-family: monospace; font-weight: bold; letter-spacing: 0.5px;
    border: 1px solid var(--accent); color: var(--accent); background: transparent;
    transition: all 0.12s; user-select: none;
  }
  .audio-mode-btn.local { border-color: var(--freq-color); color: var(--freq-color); }
  .freq-wrap { display: flex; align-items: center; gap: 4px; margin-left: auto; }
  .freq-range { width: 60px; height: 4px; cursor: pointer; accent-color: var(--freq-color); }
  .freq-label { font-size: 0.78em; color: var(--freq-color); font-weight: bold; }
  .freq-input { width: 50px; background: var(--input-bg); border: 1px solid var(--border); color: var(--freq-color); padding: 2px 4px; border-radius: 4px; font-size: 0.78em; text-align: center; font-family: monospace; }
  .vol-wrap { display: flex; align-items: center; gap: 4px; }
  .vol-range { width: 50px; height: 4px; cursor: pointer; accent-color: var(--vol-color); }
  .vol-label { font-size: 0.78em; color: var(--vol-color); font-weight: bold; }
  .vol-value { font-size: 0.78em; color: var(--text-dim); min-width: 24px; }
  .pan-wrap { display: flex; align-items: center; gap: 4px; }
  .pan-range { width: 44px; height: 4px; cursor: pointer; accent-color: var(--pan-color); }
  .pan-label { font-size: 0.78em; color: var(--pan-color); font-weight: bold; }
  .pan-value { font-size: 0.78em; color: var(--text-dim); min-width: 20px; }
  .wave-mod {
    background: var(--step-bg); border: 1px solid var(--border); color: var(--text-muted);
    padding: 2px 6px; border-radius: 4px; font-size: 0.62em; cursor: pointer;
    letter-spacing: 0.5px; transition: all 0.15s; font-family: monospace;
    user-select: none;
  }
  .wave-mod:hover { background: var(--border); color: var(--text-dim); }
  .wave-mod.active-smooth { border-color: var(--pan-color); color: var(--pan-color); background: var(--canvas-bg); }
  .wave-mod.active-bipolar { border-color: var(--freq-color); color: var(--freq-color); background: var(--canvas-bg); }
  .wave-mod.disabled { opacity: 0.3; cursor: default; }

  /* New Block: event chain */
  .ev-chain-wrap {
    display: flex; align-items: center; gap: 3px; flex-wrap: wrap;
    padding: 3px 4px; background: var(--canvas-bg); border-radius: 5px; min-height: 34px;
  }
  .ev-cell {
    width: 42px; height: 30px; border-radius: 3px;
    border: 1px solid var(--border); cursor: pointer;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    transition: background 0.08s; user-select: none; position: relative;
  }
  .ev-cell.c0 { background: color-mix(in srgb, var(--color-ch0) 18%, transparent); border-color: color-mix(in srgb, var(--color-ch0) 33%, transparent); }
  .ev-cell.c1 { background: color-mix(in srgb, var(--color-ch1) 18%, transparent); border-color: color-mix(in srgb, var(--color-ch1) 33%, transparent); }
  .ev-cell.c2 { background: color-mix(in srgb, var(--color-ch2) 18%, transparent); border-color: color-mix(in srgb, var(--color-ch2) 33%, transparent); }
  .ev-cell.crt { background: color-mix(in srgb, var(--color-rt) 18%, transparent); border-color: color-mix(in srgb, var(--color-rt) 33%, transparent); }
  .ev-cell.selected { outline: 2px dashed var(--freq-color); outline-offset: 1px; z-index: 1; }
  .ev-cell.range-selected { outline: 2px solid #f80; outline-offset: 1px; z-index: 1; background: color-mix(in srgb, #f80 20%, var(--step-bg)); }
  .ev-wave {
    font-size: 0.8em; line-height: 1; cursor: pointer; color: var(--text);
    width: 100%; text-align: center; border-radius: 3px 3px 0 0;
  }
  .ev-wave:hover { background: color-mix(in srgb, var(--text) 10%, transparent); }
  .ev-dur {
    font-size: 0.5em; line-height: 1; cursor: pointer; color: var(--text-dim);
    width: 100%; text-align: center; border-radius: 0 0 3px 3px;
  }
  .ev-dur:hover { background: rgba(255,255,255,0.1); }
  .ev-add {
    width: 26px; height: 30px; border-radius: 3px;
    border: 1px dashed var(--border); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    color: var(--text-muted); font-size: 1em; transition: all 0.15s;
  }
  .ev-add:hover { background: var(--step-bg); color: var(--text-dim); border-color: var(--text-muted); }
  .ev-add.disabled { opacity: 0.2; cursor: default; }
  .fill-gap-btn {
    display: inline-block; margin: 4px 0 0 0; padding: 3px 10px;
    background: var(--step-bg); border: 1px solid var(--border); color: var(--text-dim);
    border-radius: 4px; font-size: 0.7em; cursor: pointer; letter-spacing: 1px;
  }
  .fill-gap-btn:hover { background: var(--panel-bg); color: var(--text); border-color: var(--text-muted); }

  /* Unified grid (Block C) */
  .grid-section {
    background: var(--panel-bg); border-radius: 8px; padding: 10px; border: 1px solid var(--step-bg);
    margin-bottom: 16px;
  }
  .grid-section-label { font-size: 0.65em; color: var(--text-muted); margin-bottom: 6px; letter-spacing: 1px; }
  .u-group { margin-bottom: 8px; }
  .u-group-label { font-size: 0.55em; color: var(--border); margin-bottom: 3px; }
  .u-row { display: flex; gap: 1px; }
  .u-col { display: flex; flex-direction: column; gap: 0px; }
  .u-cell {
    width: 54px; height: 21px; border-radius: 1px;
    background: var(--step-bg); cursor: pointer;
    display: flex; align-items: center; justify-content: center;
    font-size: 10px; color: transparent; transition: background 0.06s;
    border: 1px solid transparent; user-select: none;
  }
  .u-cell:hover { filter: brightness(1.3); }
  .u-cell.inactive { opacity: 0.15; cursor: default; }

  /* ON cell */
  .u-cell.on.c0 { background: var(--color-ch0); color: var(--accent-text); }
  .u-cell.on.c1 { background: var(--color-ch1); color: var(--accent-text); }
  .u-cell.on.c2 { background: var(--color-ch2); color: var(--accent-text); }

  /* Blocked cell */
  .u-cell.blocked.c0 { background: color-mix(in srgb, var(--color-ch0) 30%, var(--step-bg)); }
  .u-cell.blocked.c1 { background: color-mix(in srgb, var(--color-ch1) 30%, var(--step-bg)); }
  .u-cell.blocked.c2 { background: color-mix(in srgb, var(--color-ch2) 30%, var(--step-bg)); }

  /* Selected */
  .u-cell.selected { outline: 1px dashed var(--freq-color); z-index: 1; }

  /* Playing column highlight */
  .u-col.playing .u-cell { box-shadow: inset 0 0 0 1px rgba(255,255,255,0.5); }

  /* Beat markers (unified grid) */
  .u-col.beat-alt .u-cell:not(.on):not(.blocked) { background: color-mix(in srgb, var(--step-bg) 80%, #fff); }
  .u-col.beat-mark { border-left: 2px solid var(--border); }

  /* Beat labels above columns */
  .u-beat-labels { display: flex; gap: 1px; }
  .u-blabel {
    width: 54px; font-size: 14px; text-align: center;
    color: var(--text-muted); height: 20px; line-height: 20px;
    white-space: nowrap; overflow: hidden;
  }
  .u-blabel.bar { color: var(--freq-color); font-weight: bold; font-size: 16px; }
  .u-blabel.half { color: var(--text-dim); }
  .u-blabel.quarter { color: var(--text-muted); }
  .u-blabel.eighth { color: var(--border); }

  /* Step number below column */
  .u-step-nums { display: flex; gap: 1px; }
  .u-snum { width: 54px; font-size: 8px; color: var(--border); text-align: center; }
  .u-col.beat-mark + .u-snum { }

  /* ============================================================
     SPLIT GRID (6-lane: 3 channels × normal + triplet)
     ============================================================ */
  .split-channel { margin-bottom: 10px; }

  /* RT section divider */
  .rt-divider {
    border: none; border-top: 2px dashed var(--color-rt);
    margin: 14px 0 8px; opacity: 0.5;
  }
  .rt-divider-label {
    font-size: 0.7em; color: var(--color-rt); letter-spacing: 2px;
    text-align: center; margin-bottom: 4px; font-weight: bold;
  }
  .rt-song-section {
    background: color-mix(in srgb, var(--color-rt) 5%, var(--panel-bg));
    border-radius: 8px; padding: 8px 10px;
    border: 1px solid color-mix(in srgb, var(--color-rt) 20%, var(--step-bg));
    margin-bottom: 10px;
  }
  .rt-song-inline {
    margin-top: 4px; padding-top: 4px;
    border-top: 1px dashed color-mix(in srgb, var(--color-rt) 40%, transparent);
  }
  .rt-song-inline::before {
    content: 'RT'; font-size: 0.6em; color: var(--color-rt);
    letter-spacing: 1px; font-weight: bold; margin-right: 6px;
  }
  .rt-pat-inline {
    display: inline-flex; align-items: center; gap: 4px;
    padding-left: 8px; border-left: 2px solid var(--color-rt);
    margin-left: 8px;
  }
  .split-ch-label {
    font-size: 0.65em; color: var(--text-muted); letter-spacing: 1px;
    margin-bottom: 2px; display: flex; align-items: center; gap: 8px;
  }
  .split-ch-label .ch-dot {
    display: inline-block; width: 8px; height: 8px; border-radius: 50%;
  }
  .lane-wrap { margin-bottom: 4px; }
  .lane-label {
    font-size: 0.5em; color: var(--border); letter-spacing: 1px;
    margin-bottom: 1px; padding-left: 2px;
  }
  .lane-beat-labels { display: flex; gap: 1px; flex-wrap: wrap; }
  .lane-blabel {
    font-size: 11px; text-align: center;
    color: var(--text-muted); height: 16px; line-height: 16px;
    white-space: nowrap; overflow: hidden;
  }
  .lane-blabel.bar { color: var(--freq-color); font-weight: bold; font-size: 13px; }
  .lane-blabel.half { color: var(--text-dim); }
  .lane-blabel.quarter { color: var(--text-muted); }
  .lane-blabel.eighth { color: var(--border); }
  .lane-blabel.triplet-div { color: var(--border-dim, var(--border)); }

  .lane-row { display: flex; gap: 1px; flex-wrap: wrap; position: relative; }

  /* Playhead bar */
  .playhead-bar {
    position: absolute; top: 0; bottom: 0; width: 2px;
    background: #3b82f6; z-index: 10; pointer-events: none;
    box-shadow: 0 0 6px 1px rgba(59, 130, 246, 0.5);
    transition: left 0.05s linear;
  }

  /* Normal lane cell (32 per bar) */
  .n-cell {
    width: 44px; height: 44px; border-radius: 1px;
    background: var(--step-bg); cursor: pointer;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    font-size: 10px; color: transparent; transition: background 0.06s;
    border: 1px solid transparent; user-select: none; position: relative;
  }
  .lane-blabel.n-lbl { width: 44px; }

  /* Triplet lane cell (48 per bar) */
  .t-cell {
    width: 30px; height: 36px; border-radius: 1px;
    background: var(--step-bg); cursor: pointer;
    display: flex; flex-direction: column; align-items: center; justify-content: center;
    font-size: 9px; color: transparent; transition: background 0.06s;
    border: 1px solid transparent; user-select: none; position: relative;
  }
  .lane-blabel.t-lbl { width: 30px; }

  /* Two-row cell content for ON cells */
  .cell-wave { font-size: 12px; line-height: 1.1; pointer-events: none; }
  .cell-dur  { font-size: 8px; line-height: 1.1; opacity: 0.75; pointer-events: none; }
  .t-cell .cell-wave { font-size: 10px; }
  .t-cell .cell-dur  { font-size: 7px; }

  /* Drag state */
  .n-cell.drag-source, .t-cell.drag-source { opacity: 0.4; }
  .n-cell.drag-over, .t-cell.drag-over { outline: 2px solid var(--freq-color); }

  .n-cell:hover, .t-cell:hover { filter: brightness(1.3); }
  .n-cell.inactive, .t-cell.inactive { opacity: 0.15; cursor: default; }

  /* ON cells */
  .n-cell.on.c0, .t-cell.on.c0 { background: var(--color-ch0); color: var(--accent-text); }
  .n-cell.on.c1, .t-cell.on.c1 { background: var(--color-ch1); color: var(--accent-text); }
  .n-cell.on.c2, .t-cell.on.c2 { background: var(--color-ch2); color: var(--accent-text); }
  .n-cell.on.crt, .t-cell.on.crt { background: var(--color-rt); color: var(--accent-text); }

  /* Blocked cells */
  .n-cell.blocked.c0, .t-cell.blocked.c0 { background: color-mix(in srgb, var(--color-ch0) 30%, var(--step-bg)); }
  .n-cell.blocked.c1, .t-cell.blocked.c1 { background: color-mix(in srgb, var(--color-ch1) 30%, var(--step-bg)); }
  .n-cell.blocked.c2, .t-cell.blocked.c2 { background: color-mix(in srgb, var(--color-ch2) 30%, var(--step-bg)); }
  .n-cell.blocked.crt, .t-cell.blocked.crt { background: color-mix(in srgb, var(--color-rt) 30%, var(--step-bg)); }

  /* Selected */
  .n-cell.selected, .t-cell.selected { outline: 1px dashed var(--freq-color); z-index: 1; }

  /* Playing highlight */
  .n-cell.playing, .t-cell.playing { box-shadow: inset 0 0 0 1px rgba(255,255,255,0.5); }

  /* Beat alt background */
  .n-cell.beat-alt:not(.on):not(.blocked) { background: color-mix(in srgb, var(--step-bg) 80%, #fff); }
  .t-cell.beat-alt:not(.on):not(.blocked) { background: color-mix(in srgb, var(--step-bg) 85%, #fff); }

  /* Beat mark border */
  .n-cell.beat-mark, .t-cell.beat-mark { border-left: 2px solid var(--border); }

  .btn-row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; }
  button.main {
    padding: 8px 18px; border: 1px solid var(--btn-border, transparent);
    border-radius: var(--btn-radius, 6px); cursor: pointer; font-size: 0.8em;
    font-family: monospace; letter-spacing: 1px; transition: all 0.15s;
  }
  button.main:hover { filter: brightness(var(--btn-hover, 0.92)); }
  #btnPlay { background: var(--btn-play); color: var(--btn-play-tx, var(--btn-text)); font-weight: bold; }
  #btnPlay.playing { background: var(--accent-active); color: #fff; }
  #btnSongPlay { background: var(--btn-song); color: var(--btn-song-tx, var(--btn-text)); font-weight: bold; }
  #btnSongPlay.playing { background: var(--accent-active); color: #fff; }
  #btnLoop { background: var(--step-bg); color: var(--text-muted); font-size: 0.7em; }
  #btnLoop.active { background: var(--canvas-bg); color: var(--btn-song-tx, var(--btn-song)); border: 1px solid var(--btn-song-tx, var(--btn-song)); }
  #btnStop { background: var(--btn-stop); color: var(--btn-stop-tx, var(--text-dim)); }
  #btnClear { background: var(--btn-clear); color: var(--btn-clear-tx, var(--text-dim)); }
  #btnExport { background: var(--btn-export); color: var(--btn-export-tx, var(--btn-text)); }
  #btnSave { background: var(--btn-save); color: var(--btn-save-tx, var(--btn-text)); }
  #btnLoad { background: var(--btn-load); color: var(--btn-load-tx, var(--text-dim)); }
  #btnSettings { background: var(--btn-settings); color: var(--btn-settings-tx, var(--btn-text)); }
  #btnRandom { background: var(--btn-random); color: var(--btn-random-tx, var(--btn-text)); }
  .rand-density { display: flex; align-items: center; gap: 6px; }
  .rand-density label { font-size: 0.7em; color: var(--text-dim); }
  .rand-density input[type=range] { width: 80px; accent-color: var(--btn-random-tx, var(--btn-random)); cursor: pointer; }
  .rand-density .rd-val { font-size: 0.7em; color: var(--text-dim); min-width: 28px; }
  #btnVary { background: var(--btn-vary); color: var(--btn-vary-tx, var(--btn-text)); }
  #btnScore { background: var(--btn-score); color: var(--btn-score-tx, var(--btn-text)); }
  #btnWav { background: var(--btn-wav); color: var(--btn-wav-tx, var(--btn-text)); }
  #btnMp3 { background: var(--btn-mp3); color: var(--btn-mp3-tx, var(--btn-text)); }

  /* Vary modal */
  .vary-overlay {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); z-index: 100; align-items: flex-start; justify-content: center;
    padding-top: 40px; overflow-y: auto;
  }
  .vary-overlay.open { display: flex; }
  .vary-box {
    background: var(--panel-bg); border: 1px solid var(--border); border-radius: 12px;
    padding: 20px 24px; min-width: 360px; max-width: 520px; width: 92%;
    margin-bottom: 40px;
  }
  .vary-title { font-size: 1em; color: var(--accent); margin-bottom: 14px; letter-spacing: 2px; text-align: center; }
  .vary-cat { font-size: 0.65em; color: var(--text-muted); margin: 10px 0 4px; letter-spacing: 1px; text-transform: uppercase; }
  .vary-grid { display: flex; flex-wrap: wrap; gap: 4px; margin-bottom: 4px; }
  .vary-btn {
    padding: 5px 10px; background: var(--step-bg); border: 1px solid var(--border); color: var(--text);
    border-radius: 4px; cursor: pointer; font-size: 0.7em; font-family: monospace;
    transition: all 0.12s; white-space: nowrap;
  }
  .vary-btn:hover { background: var(--accent); color: var(--accent-text); border-color: var(--accent); }
  .vary-close {
    display: block; margin: 14px auto 0; padding: 7px 22px;
    background: var(--border); color: var(--text); border: none; border-radius: 6px;
    cursor: pointer; font-family: monospace; font-size: 0.8em;
  }
  .vary-close:hover { background: var(--text-muted); }
  .vary-param { display: flex; align-items: center; gap: 6px; margin: 6px 0; }
  .vary-param label { font-size: 0.65em; color: var(--text-dim); }
  .vary-param input { width: 50px; background: var(--input-bg); border: 1px solid var(--border); color: var(--text); padding: 3px 5px; border-radius: 4px; font-size: 0.75em; text-align: center; }

  /* Settings modal */
  .modal-overlay {
    display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
    background: rgba(0,0,0,0.6); z-index: 100; align-items: center; justify-content: center;
  }
  .modal-overlay.open { display: flex; }
  .modal-box {
    background: var(--panel-bg); border: 1px solid var(--border); border-radius: 12px;
    padding: 24px 28px; min-width: 320px; max-width: 420px; width: 90%;
  }
  .modal-title { font-size: 1em; color: var(--accent); margin-bottom: 16px; letter-spacing: 2px; text-align: center; }
  .modal-row { display: flex; align-items: center; gap: 10px; margin-bottom: 12px; }
  .modal-label { font-size: 0.75em; color: var(--text-dim); min-width: 80px; }
  .modal-color { width: 40px; height: 26px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer; background: none; padding: 0; }
  .modal-color::-webkit-color-swatch-wrapper { padding: 0; }
  .modal-color::-webkit-color-swatch { border: none; border-radius: 3px; }
  .modal-close {
    display: block; margin: 16px auto 0; padding: 8px 24px;
    background: var(--accent); color: var(--accent-text); border: none; border-radius: 6px;
    cursor: pointer; font-family: monospace; font-size: 0.85em; font-weight: bold;
    letter-spacing: 1px;
  }
  .modal-close:hover { filter: brightness(1.15); }
  .modal-toggle {
    padding: 4px 12px; border: 1px solid var(--accent); border-radius: 4px;
    background: var(--bg-color); color: var(--accent); font-family: monospace; font-size: 0.7em;
    cursor: pointer; font-weight: bold; letter-spacing: 1px;
  }
  .modal-toggle.local { border-color: var(--freq-color); color: var(--freq-color); }
  .modal-select {
    padding: 4px 8px; border: 1px solid var(--border); border-radius: 4px;
    background: var(--canvas-bg); color: var(--text); font-family: monospace; font-size: 0.7em;
    cursor: pointer;
  }

  .status { text-align: center; font-size: 0.72em; color: var(--text-muted); margin-top: 12px; min-height: 1.2em; }
</style>
</head>
<body>
<h1>ABC Maestro SEQ</h1>
<div class="subtitle">Acid Rain Maestro LFO Simulator</div>

<div class="controls">
  <div class="ctrl-group"><label>BPM</label><input type="number" id="bpm" value="120" min="20" max="300"></div>
  <div class="ctrl-group"><label>PAT LEN</label><input type="number" id="patLen" value="128" min="1" max="128" onchange="setPatternLength(this.value)"></div>
  <button class="pat-btn" id="btnAutoLen" title="Auto-set pattern length to end of longest channel">AUTO LEN</button>
</div>

<div class="song-section">
  <div class="song-section-label">SONG</div>
  <div class="song-lane" id="songLane"></div>
  <div class="rt-song-inline">
    <div class="song-lane" id="rtSongLane"></div>
  </div>
  <div class="pattern-pool" id="patternPool">
    <span class="pattern-pool-label">POOL</span>
  </div>
</div>

<div class="btn-row">
  <button class="main" id="btnPlay">&#9654; PAT PLAY</button>
  <button class="main" id="btnSongPlay">&#9654; SONG PLAY</button>
  <button class="main" id="btnLoop">LOOP: OFF</button>
  <button class="main" id="btnStop">&#9632; STOP</button>
  <button class="main" id="btnClear">&#10005; PAT CLEAR</button>
  <button class="main" id="btnSongClear">&#10005; SONG CLEAR</button>
  <button class="main" id="btnExport">&#8595; EXPORT MIDI</button>
  <button class="main" id="btnSave">&#9744; SAVE</button>
  <button class="main" id="btnLoad">&#9745; LOAD</button>
  <input type="file" id="fileLoad" accept=".json" style="display:none">
  <span class="rand-density">
    <label>DENSITY</label>
    <input type="range" id="randDensity" min="10" max="90" value="50">
    <span class="rd-val" id="rdVal">50%</span>
  </span>
  <button class="main" id="btnRandom">&#9858; RANDOM</button>
  <button class="main" id="btnSettings">&#9881; SETTINGS</button>
  <button class="main" id="btnVary">&#9733; VARY</button>
  <button class="main" id="btnScore">&#9835; SCORE</button>
  <button class="main" id="btn16Score" style="background:var(--btn-score);color:var(--btn-score-tx, var(--btn-text))">16 SCORE</button>
  <button class="main" id="btnWav">WAV</button>
  <button class="main" id="btnMp3">MP3</button>
</div>
<div class="status" id="status">Shift+Space=Song | Shift+WAV/MP3=Song Export</div>

<div class="pattern-bar" id="patternBar">
  <label>PATTERN</label>
  <select class="pat-select" id="patSelect"></select>
  <button class="pat-btn" id="patNew">+ NEW</button>
  <button class="pat-btn" id="patRename">RENAME</button>
  <span style="font-size:0.6em;color:#555">Cmd+C/V: Copy/Paste | Cmd+D: Duplicate | Cmd+S: Save</span>
</div>
<div class="ch-blocks" id="chBlocks"></div>
<div class="ch-blocks" id="rtChBlocks"></div>
<div class="grid-section" id="gridSection">
  <div class="grid-section-label">STEP GRID</div>
  <div id="unifiedGrid"></div>
  <hr class="rt-divider" style="margin:10px 0 6px">
  <div class="pattern-bar" id="rtPatternBar" style="margin:0 0 6px;padding:4px 8px;border-color:var(--color-rt)">
    <label style="color:var(--color-rt);font-size:0.75em">RT PATTERN</label>
    <select class="pat-select" id="rtPatSelect" style="border-color:var(--color-rt)"></select>
    <button class="pat-btn" id="rtPatNew" style="border-color:var(--color-rt);color:var(--color-rt)">+ RT</button>
    <button class="pat-btn" id="rtPatRename" style="border-color:var(--color-rt);color:var(--color-rt)">RENAME</button>
  </div>
  <div id="rtGrid"></div>
</div>

<!-- Settings Modal -->
<!-- S2S Import Modal -->
<div class="modal-overlay" id="s2sModal">
  <div class="modal-box" style="max-width:500px;">
    <div class="modal-title">&#8593; S2S IMPORT → <span id="s2sChName">CH1</span></div>
    <div class="modal-row" style="flex-direction:column;align-items:stretch;gap:6px;">
      <span class="modal-label">PASTE S2S PATTERN TEXT</span>
      <textarea id="s2sText" rows="3" style="width:100%;background:var(--canvas-bg);color:var(--text);border:1px solid var(--border);border-radius:4px;font-family:monospace;font-size:0.75em;padding:6px;resize:vertical;" placeholder="S2S|BPM:120|/4 triangle, /8 ramp_up, ..."></textarea>
      <button class="modal-close" id="s2sPaste" style="margin:4px 0 0;padding:5px 12px;font-size:0.7em;background:var(--step-bg);color:var(--text-dim);">PASTE FROM CLIPBOARD</button>
    </div>
    <div class="modal-row">
      <span class="modal-label">MODE</span>
      <select class="modal-select" id="s2sMode">
        <option value="replace">REPLACE (clear ch first)</option>
        <option value="append">APPEND (add after existing)</option>
      </select>
    </div>
    <div id="s2sInfo" style="font-size:0.65em;color:var(--text-muted);min-height:1.2em;margin:8px 0;text-align:center;"></div>
    <div style="display:flex;gap:10px;justify-content:center;margin-top:8px;">
      <button class="modal-close" id="s2sCancel" style="background:var(--border);color:var(--text-dim);">CANCEL</button>
      <button class="modal-close" id="s2sApply">APPLY</button>
    </div>
  </div>
</div>

<div class="modal-overlay" id="settingsModal">
  <div class="modal-box">
    <div class="modal-title">SETTINGS</div>
    <div class="modal-row">
      <span class="modal-label">COLOR THEME</span>
      <select class="modal-select" id="cfgTheme">
        <optgroup label="── Dark ──">
          <option value="dark">Dark (Default)</option>
          <option value="teal">Teal &amp; Gold</option>
          <option value="ocean">Ocean Blue</option>
        </optgroup>
        <optgroup label="── Light ──">
          <option value="light">Light</option>
          <option value="sakura">Sakura</option>
        </optgroup>
        <optgroup label="── Bright ──">
          <option value="mint">Mint</option>
          <option value="sky">Sky</option>
          <option value="cream">Cream</option>
        </optgroup>
        <optgroup label="── Pastel ──">
          <option value="lavender">Lavender</option>
          <option value="peach">Peach</option>
        </optgroup>
      </select>
    </div>
    <div style="display:flex;gap:10px;justify-content:center;margin-top:16px;">
      <button class="modal-close" id="settingsCancel" style="background:var(--border);color:var(--text-dim);">CANCEL</button>
      <button class="modal-close" id="settingsClose">OK</button>
    </div>
  </div>
</div>

<!-- Vary Modal -->
<div class="vary-overlay" id="varyModal">
  <div class="vary-box">
    <div class="vary-title">VARIATION</div>
    <div class="vary-param">
      <label>ROTATE STEPS</label><input type="number" id="vRotate" value="2" min="1" max="32">
      <label>ECHO DELAY</label><input type="number" id="vEcho" value="2" min="1" max="16">
      <label>CHAOS %</label><input type="number" id="vChaos" value="30" min="1" max="100">
    </div>
    <div class="vary-cat">CONTRAPUNTAL</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('reverse')">Reverse</button>
      <button class="vary-btn" onclick="doVary('inversion')">Inversion</button>
      <button class="vary-btn" onclick="doVary('retro_inv')">Retro+Inv</button>
      <button class="vary-btn" onclick="doVary('augment')">Augment</button>
      <button class="vary-btn" onclick="doVary('diminish')">Diminish</button>
      <button class="vary-btn" onclick="doVary('rotate')">Rotation</button>
    </div>
    <div class="vary-cat">STRUCTURE</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('half_swap')">Half Swap</button>
      <button class="vary-btn" onclick="doVary('mirror')">Mirror</button>
    </div>
    <div class="vary-cat">DENSITY</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('density_up')">Density+</button>
      <button class="vary-btn" onclick="doVary('density_down')">Density-</button>
    </div>
    <div class="vary-cat">TIMBRE</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('wave_mutate')">Wave Mutate</button>
      <button class="vary-btn" onclick="doVary('dur_shuffle')">Dur Shuffle</button>
    </div>
    <div class="vary-cat">DIALOG</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('call_response')">Call&amp;Response</button>
      <button class="vary-btn" onclick="doVary('echo')">Echo</button>
    </div>
    <div class="vary-cat">RHYTHM</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('euclidean')">Euclidean</button>
      <button class="vary-btn" onclick="doVary('syncopation')">Syncopation</button>
    </div>
    <div class="vary-cat">MINIMALISM</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('phase_shift')">Phase Shift</button>
      <button class="vary-btn" onclick="doVary('additive')">Additive</button>
      <button class="vary-btn" onclick="doVary('subtractive')">Subtractive</button>
    </div>
    <div class="vary-cat">RANDOM</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('humanize')">Humanize</button>
      <button class="vary-btn" onclick="doVary('chaos')">Chaos</button>
    </div>
    <div class="vary-cat">CHANNEL</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('ch_swap_12')">CH1&harr;2</button>
      <button class="vary-btn" onclick="doVary('ch_swap_13')">CH1&harr;3</button>
      <button class="vary-btn" onclick="doVary('ch_swap_23')">CH2&harr;3</button>
      <button class="vary-btn" onclick="doVary('single_ch')">1CH Vary</button>
    </div>
    <div class="vary-cat">INDIAN</div>
    <div class="vary-grid">
      <button class="vary-btn" onclick="doVary('tihai')">Tihai</button>
    </div>
    <button class="vary-close" id="varyClose">CLOSE</button>
  </div>
</div>

<script>
// ============================================================
//  CONSTANTS
// ============================================================
var CNAME  = ['CH 1', 'CH 2', 'CH 3'];
var CCLASS = ['c0', 'c1', 'c2'];
var CCOLORS = ['#e11d48', '#3b82f6', '#22c55e'];
var CARRIER_FREQS = [180, 320, 520];

// RT (Real-Time) channel constants
var RT_CNAME  = 'RT';
var RT_CCLASS = 'crt';
var RT_COLOR  = '#06b6d4';
var RT_CARRIER_FREQ = 440;

// Section color options for song cells
var SEC_COLORS = ['none', 'red', 'orange', 'yellow', 'green', 'blue', 'purple'];
var GRID_COLS = 32; // fallback columns per group in unified grid

function calcGridCols() {
  var container = document.getElementById('unifiedGrid');
  if (!container) return GRID_COLS;
  var cellW = 55; // u-cell width(54) + gap(1)
  var available = container.clientWidth;
  var cols = Math.floor(available / cellW);
  return Math.max(4, cols);
}

var WAVEFORMS = [
  { id: 'ramp_up',      symbol: '\u2197', name: 'Ramp Up' },
  { id: 'ramp_down',    symbol: '\u2198', name: 'Ramp Down' },
  { id: 'triangle',     symbol: '\u25B3', name: 'Triangle' },
  { id: 'inv_triangle', symbol: '\u25BD', name: 'Inv Tri' },
  { id: 'square',       symbol: '\u25A1', name: 'Square' },
  { id: 'high',         symbol: '\u2014', name: 'High' },
  { id: 'low',          symbol: '_',      name: 'Low' },
];
var WAVE_SYM = {};
WAVEFORMS.forEach(function(w) { WAVE_SYM[w.id] = w.symbol; });
var WAVE_IDS = WAVEFORMS.map(function(w) { return w.id; });
var SMOOTH_NO_EFFECT = ['high', 'low', 'square'];

var QUANT_DURS = {
  16: [16, 8, 4, 2],
  96: [48, 32, 24, 16, 12, 8, 6, 4, 3, 2, 1],
};
var DUR_LABELS = { 32: '/32', 16: '/16', 8: '/8', 4: '/4', 2: '/2', 1: '/1' };
var TRIPLET_LABELS = {
  96: { 48: '/32T', 24: '/16T', 12: '/8T', 6: '/4T', 3: '/2T' }
};

var NORMAL_DURS  = [32, 16, 8, 4, 2, 1];  // /32, /16, /8, /4, /2, /1(whole)
var TRIPLET_DURS = [48, 24, 12, 6, 3];    // /32T, /16T, /8T, /4T, /2T
function isTripletDur(dur) { return TRIPLET_DURS.indexOf(dur) >= 0; }
function isNormalDur(dur)  { return NORMAL_DURS.indexOf(dur) >= 0; }

function durLabel(dur) {
  if (DUR_LABELS[dur]) return DUR_LABELS[dur];
  var q = getQuant();
  if (TRIPLET_LABELS[q] && TRIPLET_LABELS[q][dur]) return TRIPLET_LABELS[q][dur];
  return '/' + dur;
}

// ============================================================
//  HELPERS
// ============================================================
function getCSSVar(name) {
  return getComputedStyle(document.documentElement).getPropertyValue(name).trim();
}
function getMax()   { return 128; }
function getBPM()   { return parseInt(document.getElementById('bpm').value) || 120; }
function getQuant() { return 96; }

function getAvailableDurs() {
  var q = getQuant();
  return QUANT_DURS[q] || [q, 4, 2];
}
function durToSteps(dur) { return getQuant() / dur; }
function stepIntervalMs() { return (60000 / getBPM()) / (getQuant() / 4); }

// ============================================================
//  STATE
// ============================================================
function makeStep() {
  var avail = getAvailableDurs();
  return { on: false, wave: 'ramp_up', dur: avail[0] };
}

function makeChannels() {
  return [
    { steps: [], count: 128, note: 36, mich: 1, brushWave: 'triangle',  brushDur: 16, smooth: false, bipolar: false, selectedStep: -1, volume: 0.55, freq: CARRIER_FREQS[0], pan: 0 },
    { steps: [], count: 128, note: 38, mich: 2, brushWave: 'triangle',  brushDur: 16, smooth: false, bipolar: false, selectedStep: -1, volume: 0.45, freq: CARRIER_FREQS[1], pan: 0 },
    { steps: [], count: 128, note: 42, mich: 3, brushWave: 'triangle',  brushDur: 16, smooth: false, bipolar: false, selectedStep: -1, volume: 0.35, freq: CARRIER_FREQS[2], pan: 0 },
  ];
}

function makePattern(name) {
  return { name: name, channels: makeChannels(), baseName: name, varySuffix: '', patternLength: 128 };
}

// RT channel factory
function makeRTChannel() {
  return { steps: [], count: 128, note: 60, mich: 4, brushWave: 'triangle', brushDur: 16, smooth: false, bipolar: false, selectedStep: -1, volume: 0.50, freq: RT_CARRIER_FREQ, pan: 0 };
}

function makeRTPattern(name) {
  return { name: name, channels: [makeRTChannel()], baseName: name, varySuffix: '', patternLength: 128, coverBackFrom: -1, coverBackTo: -1 };
}

// Pattern bank
var patterns = [makePattern('A')];
var currentPatternIdx = 0;
var state = patterns[0].channels; // alias into current pattern

// RT Pattern bank (independent)
var rtPatterns = [makeRTPattern('RA')]; // α
var currentRTPatternIdx = 0;
var rtState = rtPatterns[0].channels; // alias (array of 1 channel)

// Global channel audio settings (freq, volume, pan)
var globalAudioMode = [true, true, true, true]; // per-channel: true=global, false=local (0-2=back, 3=RT)
var chMute = [false, false, false, false]; // per-channel mute (0-2=back, 3=RT)
var globalAudio = [
  { freq: CARRIER_FREQS[0], volume: 0.55, pan: 0 },
  { freq: CARRIER_FREQS[1], volume: 0.45, pan: 0 },
  { freq: CARRIER_FREQS[2], volume: 0.35, pan: 0 },
];
var rtGlobalAudio = { freq: RT_CARRIER_FREQ, volume: 0.50, pan: 0 };

// Helper: get active audio params for channel c (respects per-channel global/local toggle)
function getChAudio(c, optChannels) {
  if (globalAudioMode[c]) return globalAudio[c];
  var ch = (optChannels || state)[c];
  return { freq: ch.freq, volume: ch.volume, pan: ch.pan };
}
function getRTAudio(optChannels) {
  if (globalAudioMode[3]) return rtGlobalAudio;
  var ch = (optChannels || rtState)[0];
  return { freq: ch.freq, volume: ch.volume, pan: ch.pan };
}

// Song
var song = [{ patIdx: 0, repeat: 1 }];
var rtSong = [{ patIdx: 0, repeat: 1 }]; // RT song (1:1 with back song in Mode 1)
var songLoop = false;
var selectedSongCell = 0;    // edit focus (which pattern shows in editor)
var selectedRTSongCell = 0;  // edit focus for RT
var songPlayhead = 0;        // playback start position (shared by back & RT)
var lastSongFocus = 'back';  // 'back' or 'rt' — which song lane was last clicked
var selectedPoolIdx = -1;   // selected pattern in pool (back)
var selectedRTPoolIdx = -1; // selected RT pattern in pool

// Clipboard for Cmd+C/V
var patternClipboard = null;
var cellClipboard = null;
var rangeSelection = { channel: -1, steps: [] }; // multi-select range (back)
var rtRangeSelection = { steps: [] }; // RT multi-select range

// Playback
var isPlaying = false, curStep = 0, timer = null, audioCtx = null;
var activeAudio = [null, null, null, null]; // 3 back + 1 RT
var songPlaying = false, songPos = 0, songRepeatCount = 0;

var _switchingPattern = false;
function switchToPattern(idx) {
  idx = parseInt(idx);
  if (isNaN(idx) || idx < 0 || idx >= patterns.length) return;
  if (_switchingPattern) return; // prevent re-entrant calls
  _switchingPattern = true;
  try {
    currentPatternIdx = idx;
    state = patterns[idx].channels;
    buildUI();
    renderSongLane();
    renderRTSongLane();
    // Sync PAT LEN input
    var lenEl = document.getElementById('patLen');
    if (lenEl) lenEl.value = patterns[idx].patternLength || 128;
    // Ensure currentPatternIdx is still correct after buildUI
    currentPatternIdx = idx;
  } finally {
    _switchingPattern = false;
  }
}

function switchToRTPattern(idx) {
  idx = parseInt(idx);
  if (isNaN(idx) || idx < 0 || idx >= rtPatterns.length) return;
  currentRTPatternIdx = idx;
  rtState = rtPatterns[idx].channels;
  buildRTUI();
  renderRTSongLane();
  var rtSel = document.getElementById('rtPatSelect');
  if (rtSel) rtSel.value = idx;
}

function setPatternLength(val) {
  var v = Math.max(1, Math.min(getMax(), parseInt(val) || 96));
  patterns[currentPatternIdx].patternLength = v;
  document.getElementById('patLen').value = v;
  // Sync all channel step counts to match PAT LEN
  for (var c = 0; c < 3; c++) {
    state[c].count = v;
    var scEl = document.getElementById('sc' + c);
    if (scEl) scEl.value = v;
  }
  // Mode 1: RT pattern length follows back pattern
  if (rtPatterns[currentRTPatternIdx]) {
    rtPatterns[currentRTPatternIdx].patternLength = v;
    rtState[0].count = v;
    var rtScEl = document.getElementById('scrt');
    if (rtScEl) rtScEl.value = v;
  }
  buildUI();
  buildRTUI();
}

function autoPatternLength() {
  var maxEnd = 0;
  for (var c = 0; c < 3; c++) {
    var ch = state[c];
    for (var i = ch.count - 1; i >= 0; i--) {
      if (ch.steps[i] && ch.steps[i].on) {
        var end = i + Math.round(durToSteps(ch.steps[i].dur));
        if (end > maxEnd) maxEnd = end;
        break;
      }
    }
  }
  if (maxEnd === 0) {
    document.getElementById('status').textContent = 'No events found';
    return;
  }
  maxEnd = Math.min(maxEnd, getMax());
  setPatternLength(maxEnd);
  document.getElementById('status').textContent = 'Pattern length set to ' + maxEnd;
}

function nextPatternName() {
  var used = {};
  patterns.forEach(function(p) { used[p.name] = true; });
  for (var i = 0; i < 26; i++) {
    var name = String.fromCharCode(65 + i);
    if (!used[name]) return name;
  }
  return 'P' + (patterns.length + 1);
}

// Generate a copy-aware name: if copying pattern "C", produce "C1", "C2", etc.
function nextCopyName(srcPattern) {
  // Generate A, B, C... or A1, A2 for copies
  var base = srcPattern.baseName || srcPattern.name || 'A';
  var used = {};
  patterns.forEach(function(p) { used[p.name] = true; });
  for (var n = 1; n <= 99; n++) {
    var candidate = base + n;
    if (!used[candidate]) return { name: candidate, baseName: base, varySuffix: '' + n };
  }
  return { name: base + '_' + (patterns.length + 1), baseName: base, varySuffix: '' };
}

function nextPatternLetter() {
  var used = {};
  patterns.forEach(function(p) { used[p.name] = true; });
  for (var i = 0; i < 26; i++) {
    var name = String.fromCharCode(65 + i);
    if (!used[name]) return name;
  }
  for (var n = 2; n <= 99; n++) {
    for (var i = 0; i < 26; i++) {
      var name = String.fromCharCode(65 + i) + n;
      if (!used[name]) return name;
    }
  }
  return 'P' + (patterns.length + 1);
}

// Rename a pattern's baseName and cascade to all patterns sharing the same baseName
function renamePatternBase(oldBase, newBase) {
  if (!newBase || oldBase === newBase) return;
  for (var i = 0; i < patterns.length; i++) {
    if (patterns[i].baseName === oldBase) {
      patterns[i].baseName = newBase;
      patterns[i].name = newBase + (patterns[i].varySuffix || '');
    }
  }
}

// Refresh all display names from baseName + varySuffix (call after load)
function refreshPatternNames() {
  for (var i = 0; i < patterns.length; i++) {
    var p = patterns[i];
    if (!p.baseName) p.baseName = p.name.charAt(0) || String.fromCharCode(65 + i);
    if (!p.varySuffix) p.varySuffix = '';
    p.name = p.baseName + p.varySuffix;
  }
}

// ============================================================
//  BLOCKED STEP COMPUTATION
// ============================================================
function computeBlocked(ch) {
  var max = getMax();
  var blocked = [];
  for (var i = 0; i < max; i++) blocked.push(false);
  var limit = Math.min(ch.count, max);
  for (var i = 0; i < limit; i++) {
    if (ch.steps[i] && ch.steps[i].on) {
      var span = durToSteps(ch.steps[i].dur);
      for (var j = 1; j < span && i + j < limit; j++) {
        blocked[i + j] = true;
      }
    }
  }
  return blocked;
}

// ============================================================
//  EVENT CHAIN (New Block data)
// ============================================================
function getEventChain(c) {
  var ch = state[c];
  var events = [];
  for (var i = 0; i < ch.count; i++) {
    if (ch.steps[i] && ch.steps[i].on) {
      events.push({ step: i, wave: ch.steps[i].wave, dur: ch.steps[i].dur });
    }
  }
  return events;
}

function getNextFreeStep(c) {
  var ch = state[c];
  var blocked = computeBlocked(ch);
  var gridStep = isTripletDur(ch.brushDur) ? 2 : 3;

  // Find position after last event
  var start = 0;
  for (var i = ch.count - 1; i >= 0; i--) {
    if (ch.steps[i] && ch.steps[i].on) {
      start = i + Math.round(durToSteps(ch.steps[i].dur));
      break;
    }
    if (blocked[i]) continue;
  }

  // Find next grid-aligned, non-blocked, non-occupied position
  for (var pos = start; pos < ch.count; pos++) {
    if (pos % gridStep !== 0) continue;
    if (ch.steps[pos] && ch.steps[pos].on) continue;
    if (blocked[pos]) continue;
    return pos;
  }
  return -1;
}

// ============================================================
//  REPACK EVENTS (close gaps, shift following events)
// ============================================================
function repackEvents(c) {
  var ch = state[c];
  // Collect all ON events in order
  var events = [];
  for (var i = 0; i < ch.count; i++) {
    if (ch.steps[i] && ch.steps[i].on) {
      events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur });
    }
  }
  // Clear all steps
  for (var i = 0; i < ch.steps.length; i++) {
    ch.steps[i].on = false;
    ch.steps[i].wave = 'triangle';
    ch.steps[i].dur = 16;
  }
  // Re-place events contiguously
  var pos = 0;
  for (var e = 0; e < events.length; e++) {
    var span = durToSteps(events[e].dur);
    if (pos + span > ch.count) {
      // Doesn't fit — try shorter durations
      var avail = getAvailableDurs();
      var fitted = false;
      for (var a = 0; a < avail.length; a++) {
        var trySpan = durToSteps(avail[a]);
        if (pos + trySpan <= ch.count) {
          events[e].dur = avail[a];
          span = trySpan;
          fitted = true;
          break;
        }
      }
      if (!fitted) break; // No room at all, drop remaining events
    }
    ch.steps[pos].on = true;
    ch.steps[pos].wave = events[e].wave;
    ch.steps[pos].dur = events[e].dur;
    pos += span;
  }
}

// ============================================================
//  LFO WAVEFORM GENERATOR
// ============================================================
function getLFOValue(type, smooth, t) {
  t = Math.max(0, Math.min(t, 0.9999));
  switch (type) {
    case 'ramp_up': return smooth ? (1 - Math.cos(Math.PI * t)) / 2 : t;
    case 'ramp_down': return smooth ? (1 + Math.cos(Math.PI * t)) / 2 : 1 - t;
    case 'triangle':
      if (smooth) return (Math.sin(2 * Math.PI * t - Math.PI / 2) + 1) / 2;
      return t < 0.5 ? 2 * t : 2 * (1 - t);
    case 'inv_triangle':
      if (smooth) return (Math.cos(2 * Math.PI * t) + 1) / 2;
      return t < 0.5 ? 1 - 2 * t : 2 * t - 1;
    case 'square': return t < 0.5 ? 1 : 0;
    case 'high': return 1;
    case 'low': return 0;
    default: return 0;
  }
}

// ============================================================
//  WAVEFORM PREVIEW CANVAS
// ============================================================
function drawWaveformPreview(c) {
  var canvas = document.getElementById('wv' + c);
  if (!canvas) return;
  var ctx = canvas.getContext('2d');
  var W = canvas.width, H = canvas.height;
  var ch = state[c];
  var pad = 3;
  ctx.fillStyle = getCSSVar('--canvas-bg') || '#12122a';
  ctx.fillRect(0, 0, W, H);
  var baseY = ch.bipolar ? H / 2 : H - pad;
  if (ch.bipolar) {
    ctx.strokeStyle = getCSSVar('--step-bg') || '#2a2a4a'; ctx.lineWidth = 1;
    ctx.setLineDash([2, 2]);
    ctx.beginPath(); ctx.moveTo(0, H/2); ctx.lineTo(W, H/2); ctx.stroke();
    ctx.setLineDash([]);
  }
  var showWave = (ch.selectedStep >= 0 && ch.steps[ch.selectedStep] && ch.steps[ch.selectedStep].on)
    ? ch.steps[ch.selectedStep].wave : ch.brushWave;
  var points = [];
  for (var px = 0; px < W; px++) {
    var t = px / (W - 1);
    var v = getLFOValue(showWave, ch.smooth, t);
    if (ch.bipolar) { v = v * 2 - 1; points.push(H/2 - v * (H/2 - pad)); }
    else { points.push(H - pad - v * (H - 2 * pad)); }
  }
  ctx.beginPath(); ctx.moveTo(0, baseY);
  for (var x = 0; x < W; x++) ctx.lineTo(x, points[x]);
  ctx.lineTo(W - 1, baseY); ctx.closePath();
  ctx.fillStyle = CCOLORS[c] + '18'; ctx.fill();
  ctx.beginPath();
  for (var x = 0; x < W; x++) { if (x === 0) ctx.moveTo(x, points[x]); else ctx.lineTo(x, points[x]); }
  ctx.strokeStyle = CCOLORS[c]; ctx.lineWidth = 1.5; ctx.stroke();
}

// ============================================================
//  SONG LANE RENDERING
// ============================================================
// Helper: select a back song position (sets playhead, does NOT change RT selection)
function selectSongPosition(idx) {
  selectedSongCell = idx;
  songPlayhead = idx;
  lastSongFocus = 'back';
  switchToPattern(song[idx].patIdx);
  renderSongLane();
  renderRTSongLane();  // update playhead marker on RT lane
}

function selectRTSongPosition(idx) {
  selectedRTSongCell = idx;
  songPlayhead = idx;
  lastSongFocus = 'rt';
  switchToRTPattern(rtSong[idx].patIdx);
  renderSongLane();   // update playhead marker on back lane
  renderRTSongLane();
}

function renderSongLane() {
  var wrap = document.getElementById('songLane');
  if (!wrap) return;
  wrap.innerHTML = '';

  song.forEach(function(entry, idx) {
    var pat = patterns[entry.patIdx];
    var cell = document.createElement('div');
    cell.className = 'song-cell';
    if (entry.sectionColor && entry.sectionColor !== 'none') cell.classList.add('sec-' + entry.sectionColor);
    if (idx === selectedSongCell) cell.classList.add('active');
    if (idx === songPlayhead) cell.classList.add('song-playhead');
    cell.draggable = true;
    cell.setAttribute('data-song-idx', idx);

    var nameEl = document.createElement('div');
    nameEl.className = 'sc-name';
    nameEl.textContent = pat ? pat.name : '?';

    var repeatWrap = document.createElement('div');
    repeatWrap.className = 'sc-repeat-wrap';
    var repeatLabel = document.createElement('span');
    repeatLabel.className = 'sc-repeat-label';
    repeatLabel.textContent = 'x';
    var repeatInput = document.createElement('input');
    repeatInput.className = 'sc-repeat-input';
    repeatInput.type = 'number';
    repeatInput.min = 1; repeatInput.max = 99;
    repeatInput.value = entry.repeat;
    repeatInput.addEventListener('click', function(e) { e.stopPropagation(); });
    repeatInput.addEventListener('change', (function(ent) {
      return function() { ent.repeat = Math.max(1, Math.min(99, parseInt(this.value) || 1)); this.value = ent.repeat; };
    })(entry));
    repeatWrap.appendChild(repeatLabel);
    repeatWrap.appendChild(repeatInput);

    // Delete button
    var delBtn = document.createElement('div');
    delBtn.className = 'sc-delete';
    delBtn.textContent = '\u00D7';
    delBtn.addEventListener('click', (function(i) {
      return function(e) {
        e.stopPropagation();
        if (song.length <= 1) return;
        song.splice(i, 1);
        if (selectedSongCell >= song.length) selectedSongCell = song.length - 1;
        if (songPlayhead >= song.length) songPlayhead = song.length - 1;
        renderSongLane(); renderPatternPool();
      };
    })(idx));

    // Click: select this cell (unified with RT)
    cell.addEventListener('click', (function(i) {
      return function(e) {
        if (e.target.classList.contains('sc-delete') || e.target.classList.contains('sc-repeat-input')) return;
        selectSongPosition(i);
      };
    })(idx));

    // Double-click name: rename this specific pattern
    nameEl.addEventListener('dblclick', (function(ent) {
      return function(e) {
        e.stopPropagation();
        var p = patterns[ent.patIdx];
        if (!p) return;
        var newName = prompt('Rename pattern "' + p.name + '" to:', p.name);
        if (newName && newName.trim().length > 0 && newName !== p.name) {
          p.name = newName.trim();
          p.baseName = newName.trim();
          p.varySuffix = '';
          renderSongLane(); renderPatternSelect(); renderPatternPool();
        }
      };
    })(entry));

    // Right-click: section color
    cell.addEventListener('contextmenu', (function(ent) {
      return function(e) {
        e.preventDefault();
        var cur = ent.sectionColor || 'none';
        var ci = SEC_COLORS.indexOf(cur);
        ent.sectionColor = SEC_COLORS[(ci + 1) % SEC_COLORS.length];
        renderSongLane();
      };
    })(entry));

    // D&D handlers
    cell.addEventListener('dragstart', (function(i) {
      return function(e) {
        e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'back-song', idx: i }));
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(function() { cell.classList.add('drag-source'); }, 0);
      };
    })(idx));
    cell.addEventListener('dragend', function() {
      document.querySelectorAll('.drag-source,.drag-over-left,.drag-over-right').forEach(function(el) {
        el.classList.remove('drag-source', 'drag-over-left', 'drag-over-right');
      });
    });
    cell.addEventListener('dragover', function(e) {
      e.preventDefault();
      var rect = cell.getBoundingClientRect();
      cell.classList.remove('drag-over-left', 'drag-over-right');
      cell.classList.add(e.clientX < rect.left + rect.width / 2 ? 'drag-over-left' : 'drag-over-right');
    });
    cell.addEventListener('dragleave', function() { cell.classList.remove('drag-over-left', 'drag-over-right'); });
    cell.addEventListener('drop', (function(dropIdx) {
      return function(e) {
        e.preventDefault();
        cell.classList.remove('drag-over-left', 'drag-over-right');
        try {
          var data = JSON.parse(e.dataTransfer.getData('text/plain'));
          var rect = cell.getBoundingClientRect();
          var insertAfter = e.clientX >= rect.left + rect.width / 2;
          if (data.type === 'back-song') {
            var fromIdx = data.idx;
            if (fromIdx === dropIdx) return;
            var item = song.splice(fromIdx, 1)[0];
            var toIdx = fromIdx < dropIdx ? (insertAfter ? dropIdx : dropIdx - 1) : (insertAfter ? dropIdx + 1 : dropIdx);
            song.splice(toIdx, 0, item);
            selectedSongCell = toIdx;
          } else if (data.type === 'pool') {
            var toIdx = insertAfter ? dropIdx + 1 : dropIdx;
            song.splice(toIdx, 0, { patIdx: data.patIdx, repeat: 1 });
            selectedSongCell = toIdx;
          }
          renderSongLane(); renderPatternPool();
        } catch(ex) {}
      };
    })(idx));

    cell.appendChild(delBtn);
    cell.appendChild(nameEl);
    cell.appendChild(repeatWrap);
    wrap.appendChild(cell);
  });

  // Add button
  var addBtn = document.createElement('div');
  addBtn.className = 'song-add';
  addBtn.textContent = '+';
  addBtn.addEventListener('click', function() {
    // Create a blank new pattern (not a copy)
    var name = nextPatternLetter();
    var pat = makePattern(name);
    pat.patternLength = patterns.length > 0 ? (patterns[currentPatternIdx >= 0 ? currentPatternIdx : 0].patternLength || 128) : 128;
    for (var c = 0; c < 3; c++) pat.channels[c].count = pat.patternLength;
    patterns.push(pat);
    song.push({ patIdx: patterns.length - 1, repeat: 1 });
    selectSongPosition(song.length - 1);
  });
  addBtn.addEventListener('dragover', function(e) { e.preventDefault(); addBtn.style.borderColor = 'var(--freq-color)'; });
  addBtn.addEventListener('dragleave', function() { addBtn.style.borderColor = ''; });
  addBtn.addEventListener('drop', function(e) {
    e.preventDefault(); addBtn.style.borderColor = '';
    try {
      var data = JSON.parse(e.dataTransfer.getData('text/plain'));
      if (data.type === 'pool') {
        song.push({ patIdx: data.patIdx, repeat: 1 });
        selectedSongCell = song.length - 1;
        renderSongLane(); renderPatternPool();
      }
    } catch(ex) {}
  });
  wrap.appendChild(addBtn);
  renderPatternPool();
}

var _patSelectLocked = false;
function renderPatternSelect() {
  var sel = document.getElementById('patSelect');
  if (!sel) return;
  _patSelectLocked = true;
  sel.innerHTML = '';
  patterns.forEach(function(p, idx) {
    var opt = document.createElement('option');
    opt.value = idx;
    opt.textContent = p.name;
    if (idx === currentPatternIdx) opt.selected = true;
    sel.appendChild(opt);
  });
  _patSelectLocked = false;
}

// ============================================================
//  PATTERN POOL — shows patterns not currently in song
// ============================================================
function renderPatternPool() {
  var wrap = document.getElementById('patternPool');
  if (!wrap) return;
  wrap.innerHTML = '<span class="pattern-pool-label">POOL</span>';

  var usedInSong = {};
  song.forEach(function(e) { usedInSong[e.patIdx] = true; });

  patterns.forEach(function(pat, idx) {
    var el = document.createElement('div');
    el.className = 'pool-cell';
    if (idx === selectedPoolIdx) el.style.outline = '2px solid var(--accent)';
    el.textContent = pat.name;
    el.draggable = true;
    if (!usedInSong[idx]) { el.style.opacity = '0.35'; }
    else { el.style.fontWeight = 'bold'; }

    el.addEventListener('dragstart', function(e) {
      e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'pool', patIdx: idx }));
      e.dataTransfer.effectAllowed = 'copy';
    });
    el.addEventListener('click', function() {
      selectedPoolIdx = idx; selectedRTPoolIdx = -1; lastSongFocus = 'back';
      switchToPattern(idx); renderPatternPool();
    });
    if (!usedInSong[idx]) {
      el.addEventListener('dblclick', function() {
        song.push({ patIdx: idx, repeat: 1 });
        selectedSongCell = song.length - 1;
        switchToPattern(idx); renderSongLane(); renderPatternPool();
      });
      // Delete button for unused patterns (only if more than 1 pattern)
      if (patterns.length > 1) {
        var delBtn = document.createElement('span');
        delBtn.textContent = '\u00d7';
        delBtn.className = 'pool-del-btn';
        delBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          deletePoolPattern('back', idx);
        });
        el.appendChild(delBtn);
      }
    }
    wrap.appendChild(el);
  });

  var sep = document.createElement('span');
  sep.style.cssText = 'border-left:2px solid var(--color-rt);height:20px;margin:0 6px';
  wrap.appendChild(sep);
  var rtLabel = document.createElement('span');
  rtLabel.style.cssText = 'font-size:0.6em;color:var(--color-rt);letter-spacing:1px;font-weight:bold';
  rtLabel.textContent = 'RT';
  wrap.appendChild(rtLabel);

  var rtUsed = {};
  rtSong.forEach(function(e) { rtUsed[e.patIdx] = true; });

  rtPatterns.forEach(function(pat, idx) {
    var el = document.createElement('div');
    el.className = 'pool-cell';
    el.style.borderColor = 'var(--color-rt)';
    el.style.color = 'var(--color-rt)';
    if (idx === selectedRTPoolIdx) el.style.outline = '2px solid var(--color-rt)';
    el.textContent = pat.name;
    if (!rtUsed[idx]) { el.style.opacity = '0.35'; }
    else { el.style.fontWeight = 'bold'; }

    el.addEventListener('click', function() {
      selectedRTPoolIdx = idx; selectedPoolIdx = -1; lastSongFocus = 'rt';
      switchToRTPattern(idx); renderPatternPool();
    });
    if (!rtUsed[idx]) {
      el.addEventListener('dblclick', function() {
        rtSong.push({ patIdx: idx, repeat: 1 });
        selectedRTSongCell = rtSong.length - 1;
        switchToRTPattern(idx); renderRTSongLane(); renderPatternPool();
      });
      if (rtPatterns.length > 1) {
        var delBtn = document.createElement('span');
        delBtn.textContent = '\u00d7';
        delBtn.className = 'pool-del-btn';
        delBtn.addEventListener('click', function(e) {
          e.stopPropagation();
          deletePoolPattern('rt', idx);
        });
        el.appendChild(delBtn);
      }
    }
    wrap.appendChild(el);
  });
}

// ============================================================
//  BUILD UI
// ============================================================
function buildUI() {
  var max = getMax();
  var avail = getAvailableDurs();

  state.forEach(function(ch) {
    while (ch.steps.length < max) ch.steps.push(makeStep());
    if (ch.count > max) ch.count = max;
    if (avail.indexOf(ch.brushDur) < 0) ch.brushDur = avail[0];
    for (var i = 0; i < ch.steps.length; i++) {
      if (ch.steps[i].on && avail.indexOf(ch.steps[i].dur) < 0) {
        ch.steps[i].dur = avail[0];
      }
    }
  });

  buildChannelBlocks();
  renderSplitGrid();
  renderSongLane();
  renderPatternSelect();
}

function buildChannelBlocks() {
  var avail = getAvailableDurs();
  var wrap = document.getElementById('chBlocks');
  wrap.innerHTML = '';

  state.forEach(function(ch, c) {
    var block = document.createElement('div');
    block.className = 'ch-block';

    var smoothDisabled = SMOOTH_NO_EFFECT.indexOf(ch.brushWave) >= 0;
    var smoothClass = ch.smooth && !smoothDisabled ? 'wave-mod active-smooth' : (smoothDisabled ? 'wave-mod disabled' : 'wave-mod');
    var bipolarClass = ch.bipolar ? 'wave-mod active-bipolar' : 'wave-mod';

    var waveOptions = WAVEFORMS.map(function(w) {
      return '<option value="' + w.id + '"' + (ch.brushWave === w.id ? ' selected' : '') + '>' + w.symbol + ' ' + w.name + '</option>';
    }).join('');
    var durOptions = avail.map(function(d) {
      return '<option value="' + d + '"' + (ch.brushDur === d ? ' selected' : '') + '>' + durLabel(d) + '</option>';
    }).join('');

    var max = getMax();

    block.innerHTML =
      /* Block A */
      '<div class="ch-header">' +
        '<div class="ch-name ' + CCLASS[c] + '">' + CNAME[c] + '</div>' +
        '<button class="audio-mode-btn' + (chMute[c] ? ' muted' : '') + '" onclick="toggleMute(' + c + ')" style="margin-left:4px;font-size:0.7em;' + (chMute[c] ? 'background:#e11d48;color:#fff' : '') + '" title="Mute/Unmute">M</button>' +
        '<div class="steps-ctrl">' +
          '<button class="sc-btn" onclick="adjCount(' + c + ',-1)">\u2212</button>' +
          '<input class="sc-input" type="number" id="sc' + c + '" value="' + ch.count + '" min="1" max="' + max + '" onchange="setCount(' + c + ', this.value)">' +
          '<button class="sc-btn" onclick="adjCount(' + c + ',1)">+</button>' +
          '<span style="font-size:0.6em;color:#555;margin-left:2px">steps</span>' +
        '</div>' +
        '<div class="midi-cfg">' +
          '<label>NOTE</label><input type="number" id="note' + c + '" value="' + ch.note + '" min="0" max="127" onchange="state[' + c + '].note=parseInt(this.value)">' +
          '<label>MIDI CH</label><input type="number" id="mich' + c + '" value="' + ch.mich + '" min="1" max="16" onchange="state[' + c + '].mich=parseInt(this.value)">' +
        '</div>' +
      '</div>' +
      /* Block B */
      '<div class="ch-wave-row">' +
        '<canvas class="wave-preview" id="wv' + c + '" width="80" height="26"></canvas>' +
        '<span class="sel-label" id="slabel' + c + '">DEFAULT</span>' +
        '<select class="wave-sel" id="wsel' + c + '" onchange="onWaveSelect(' + c + ', this.value)">' + waveOptions + '</select>' +
        '<select class="wave-sel dur-sel" id="dsel' + c + '" onchange="onDurSelect(' + c + ', parseInt(this.value))">' + durOptions + '</select>' +
        '<button class="' + smoothClass + '" id="wsmooth' + c + '" onclick="toggleSmooth(' + c + ')">S</button>' +
        '<button class="' + bipolarClass + '" id="wbipolar' + c + '" onclick="toggleBipolar(' + c + ')">B</button>' +
        '<div class="freq-wrap">' +
          '<button class="audio-mode-btn' + (globalAudioMode[c] ? '' : ' local') + '" onclick="toggleAudioMode(' + c + ')">' + (globalAudioMode[c] ? 'G' : 'L') + '</button>' +
          '<span class="freq-label">Hz</span>' +
          '<input type="range" class="freq-range" id="freq' + c + '" min="50" max="2000" value="' + getChAudio(c).freq + '" oninput="setFreq(' + c + ', this.value)">' +
          '<input type="number" class="freq-input" id="freqv' + c + '" min="50" max="2000" value="' + getChAudio(c).freq + '" onchange="setFreqInput(' + c + ', this.value)">' +
        '</div>' +
        '<div class="vol-wrap">' +
          '<span class="vol-label">VOL</span>' +
          '<input type="range" class="vol-range" id="vol' + c + '" min="0" max="100" value="' + Math.round(getChAudio(c).volume * 100) + '" oninput="setVolume(' + c + ', this.value)">' +
          '<span class="vol-value" id="volv' + c + '">' + Math.round(getChAudio(c).volume * 100) + '</span>' +
        '</div>' +
        '<div class="pan-wrap">' +
          '<span class="pan-label">PAN</span>' +
          '<input type="range" class="pan-range" id="pan' + c + '" min="-100" max="100" value="' + getChAudio(c).pan + '" oninput="setPan(' + c + ', this.value)">' +
          '<span class="pan-value" id="panv' + c + '">' + (getChAudio(c).pan === 0 ? 'C' : (getChAudio(c).pan < 0 ? 'L' + Math.abs(getChAudio(c).pan) : 'R' + getChAudio(c).pan)) + '</span>' +
        '</div>' +
      '</div>' +
      /* New Block (event chain) */
      '<div class="ev-chain-wrap" id="evchain' + c + '"></div>' +
      '<button class="fill-gap-btn" onclick="fillGaps(' + c + ')" title="Fill gaps with Low">FILL GAP</button>' +
      '<button class="fill-gap-btn" onclick="clearChannel(' + c + ')" title="Clear this channel" style="margin-left:4px;background:#e11d48;color:#fff">CLR</button>' +
      '<button class="fill-gap-btn" onclick="openS2SImport(' + c + ', false)" title="Import from Shape\u2192Sound" style="margin-left:4px;background:var(--btn-score);color:var(--btn-score-tx, var(--btn-text))">&#8593; S2S</button>';

    wrap.appendChild(block);
    renderEventChain(c);
    drawWaveformPreview(c);
  });
}

// ============================================================
//  RENDER EVENT CHAIN (New Block)
// ============================================================
function renderEventChain(c) {
  var wrap = document.getElementById('evchain' + c);
  if (!wrap) return;
  wrap.innerHTML = '';
  var ch = state[c];
  var events = getEventChain(c);

  events.forEach(function(ev, idx) {
    var el = document.createElement('div');
    el.className = 'ev-cell ' + CCLASS[c];
    if (ch.selectedStep === ev.step) el.classList.add('selected');
    if (rangeSelection.channel === c && rangeSelection.steps.indexOf(ev.step) >= 0) el.classList.add('range-selected');

    el.innerHTML =
      '<div class="ev-wave" data-area="wave">' + WAVE_SYM[ev.wave] + '</div>' +
      '<div class="ev-dur" data-area="dur">' + durLabel(ev.dur) + '</div>';

    el.addEventListener('click', (function(c, step) {
      return function(event) { evChainSelect(c, step, event); };
    })(c, ev.step));
    el.addEventListener('dblclick', (function(c, step) {
      return function(event) { evChainClick(c, step, event); };
    })(c, ev.step));

    wrap.appendChild(el);
  });

  // Add [+] button
  var nextFree = getNextFreeStep(c);
  var addBtn = document.createElement('div');
  addBtn.className = 'ev-add';
  if (nextFree < 0 || nextFree >= ch.count) {
    addBtn.classList.add('disabled');
    addBtn.textContent = '\u00B7';
  } else {
    addBtn.textContent = '+';
    addBtn.addEventListener('click', function() { addEventAtEnd(c); });
  }
  wrap.appendChild(addBtn);
}

// Single click: select only. Shift+click: range select.
function evChainSelect(c, step, event) {
  var ch = state[c];
  var s = ch.steps[step];
  if (!s || !s.on) return;

  if (event.shiftKey && ch.selectedStep >= 0 && rangeSelection.channel === c) {
    // Shift+click: extend range from selectedStep to this step
    var from = ch.selectedStep;
    var to = step;
    if (from > to) { var tmp = from; from = to; to = tmp; }
    rangeSelection.channel = c;
    rangeSelection.steps = [];
    for (var i = from; i <= to; i++) {
      if (ch.steps[i] && ch.steps[i].on) {
        rangeSelection.steps.push(i);
      }
    }
    renderEventChain(c);
    renderSplitGrid();
    document.getElementById('status').textContent = rangeSelection.steps.length + ' cells selected (Delete to remove)';
    return;
  }

  // Normal click: clear range, select single
  rangeSelection = { channel: c, steps: [step] };
  selectStep(c, step);
}

// Double click: change wave or duration
function evChainClick(c, step, event) {
  var area = event.target.getAttribute('data-area');
  var ch = state[c];
  var s = ch.steps[step];
  if (!s || !s.on) return;

  if (area === 'wave') {
    var idx = WAVE_IDS.indexOf(s.wave);
    s.wave = WAVE_IDS[(idx + 1) % WAVE_IDS.length];
    // Sync CH block wave selector
    var wSelEl = document.getElementById('wsel' + c);
    if (wSelEl) wSelEl.value = s.wave;
    updateWaveUI(c);
    selectStep(c, step);
  } else if (area === 'dur') {
    // Find which event index this is (0th, 1st, 2nd, etc.)
    var evBefore = getEventChain(c);
    var evIdx = -1;
    for (var ei = 0; ei < evBefore.length; ei++) {
      if (evBefore[ei].step === step) { evIdx = ei; break; }
    }

    var avail = getAvailableDurs();
    var posOnNorm = (step % 3 === 0);
    var posOnTrip = (step % 2 === 0);
    var compatAvail = avail.filter(function(d) {
      if (posOnNorm && isNormalDur(d)) return true;
      if (posOnTrip && isTripletDur(d)) return true;
      return false;
    });
    if (compatAvail.length === 0) compatAvail = avail;
    var curIdx = compatAvail.indexOf(s.dur);
    if (curIdx < 0) curIdx = 0;
    s.dur = compatAvail[(curIdx + 1) % compatAvail.length];

    // Repack all events (auto-shift following events)
    repackEvents(c);

    // Re-select same event by chain index
    var evAfter = getEventChain(c);
    if (evIdx >= 0 && evIdx < evAfter.length) {
      selectStep(c, evAfter[evIdx].step);
    } else {
      buildUI();
    }
  } else {
    selectStep(c, step);
  }
}

function addEventAtEnd(c) {
  var ch = state[c];
  var nextFree = getNextFreeStep(c);
  if (nextFree < 0 || nextFree >= ch.count) return;

  var step = ch.steps[nextFree];
  step.on = true;
  step.wave = ch.brushWave;
  step.dur = ch.brushDur;

  // Ensure duration fits
  var avail = getAvailableDurs();
  var span = durToSteps(step.dur);
  var attempts = 0;
  while (nextFree + span > ch.count && attempts < avail.length) {
    var idx = avail.indexOf(step.dur);
    if (idx <= 0) break;
    step.dur = avail[idx - 1];
    span = durToSteps(step.dur);
    attempts++;
  }

  // If shortest duration still doesn't fit, cancel the add
  span = durToSteps(step.dur);
  if (nextFree + span > ch.count) {
    step.on = false;
    return;
  }

  // Clear overlapping
  for (var j = 1; j < span && nextFree + j < ch.count; j++) {
    ch.steps[nextFree + j].on = false;
  }

  selectStep(c, nextFree);
}

// ============================================================
//  RENDER SPLIT GRID (6-lane: 3 channels × normal + triplet)
// ============================================================
function getLaneNCells() { return Math.ceil(getMax() / 3); }  // normal lane cells
function getLaneTCells() { return Math.ceil(getMax() / 2); }  // triplet lane cells
var N_CELL_W = 45;      // px width for normal cell (including gap)
var T_CELL_W = 31;      // px width for triplet cell (including gap)
var CH_NAMES = ['CH1', 'CH2', 'CH3'];

function renderSplitGrid() {
  var gridEl = document.getElementById('unifiedGrid');
  gridEl.innerHTML = '';

  var blockedArr = state.map(function(ch) { return computeBlocked(ch); });

  for (var c = 0; c < 3; c++) {
    var ch = state[c];
    var chDiv = document.createElement('div');
    chDiv.className = 'split-channel';

    // Channel label
    var chLabel = document.createElement('div');
    chLabel.className = 'split-ch-label';
    var dot = document.createElement('span');
    dot.className = 'ch-dot';
    dot.style.background = 'var(--color-ch' + c + ')';
    chLabel.appendChild(dot);
    var nameSpan = document.createElement('span');
    nameSpan.textContent = CH_NAMES[c];
    chLabel.appendChild(nameSpan);

    // Brush selectors in grid (dual-purpose: brush when no selection, edit when step selected)
    var brushWrap = document.createElement('span');
    brushWrap.style.cssText = 'margin-left:10px;display:inline-flex;gap:4px;align-items:center;';
    var waveSel = document.createElement('select');
    waveSel.id = 'gwsel' + c;
    waveSel.style.cssText = 'background:var(--input-bg);border:1px solid var(--border);color:var(--text);padding:1px 3px;border-radius:3px;font-size:0.75em;';
    WAVEFORMS.forEach(function(w) {
      var opt = document.createElement('option');
      opt.value = w.id; opt.textContent = w.symbol + ' ' + w.name;
      if (ch.brushWave === w.id) opt.selected = true;
      waveSel.appendChild(opt);
    });
    waveSel.addEventListener('change', (function(c) { return function() { onWaveSelect(c, this.value); }; })(c));
    var durSel = document.createElement('select');
    durSel.id = 'gdsel' + c;
    durSel.style.cssText = 'background:var(--input-bg);border:1px solid var(--border);color:var(--text);padding:1px 3px;border-radius:3px;font-size:0.75em;';
    getAvailableDurs().forEach(function(d) {
      var opt = document.createElement('option');
      opt.value = d; opt.textContent = durLabel(d);
      if (ch.brushDur === d) opt.selected = true;
      durSel.appendChild(opt);
    });
    durSel.addEventListener('change', (function(c) { return function() { onDurSelect(c, parseInt(this.value)); }; })(c));
    // Add button for grid
    var addBtn = document.createElement('button');
    addBtn.textContent = '+';
    addBtn.style.cssText = 'background:var(--accent);color:#fff;border:none;border-radius:3px;padding:1px 6px;font-size:0.75em;cursor:pointer;';
    addBtn.addEventListener('click', (function(c) { return function() {
      var nextFree = getNextFreeStep(c);
      if (nextFree >= 0 && nextFree < state[c].count) {
        var step = state[c].steps[nextFree];
        step.on = true; step.wave = state[c].brushWave; step.dur = state[c].brushDur;
        var span = durToSteps(step.dur);
        for (var j = 1; j < span && nextFree + j < state[c].count; j++) state[c].steps[nextFree + j].on = false;
        selectStep(c, nextFree);
      }
    }; })(c));
    brushWrap.appendChild(waveSel);
    brushWrap.appendChild(durSel);
    brushWrap.appendChild(addBtn);
    chLabel.appendChild(brushWrap);

    chDiv.appendChild(chLabel);

    // Normal lane
    chDiv.appendChild(buildLane(c, ch, blockedArr[c], 'normal'));

    // Triplet lane
    chDiv.appendChild(buildLane(c, ch, blockedArr[c], 'triplet'));

    gridEl.appendChild(chDiv);
  }
}

function buildLane(c, ch, blocked, laneType) {
  var isNorm = (laneType === 'normal');
  var totalCells = isNorm ? getLaneNCells() : getLaneTCells();
  var tickMul = isNorm ? 3 : 2;   // cell i → tick i*tickMul
  var cellClass = isNorm ? 'n-cell' : 't-cell';
  var lblClass = isNorm ? 'n-lbl' : 't-lbl';
  var cellW = isNorm ? N_CELL_W : T_CELL_W;

  var wrap = document.createElement('div');
  wrap.className = 'lane-wrap';

  // Lane label
  var ll = document.createElement('div');
  ll.className = 'lane-label';
  ll.textContent = isNorm ? 'NORMAL' : 'TRIPLET';
  wrap.appendChild(ll);

  // Calculate wrapping
  var container = document.getElementById('unifiedGrid');
  var availW = container ? container.clientWidth : 900;
  var maxPerRow = Math.max(4, Math.floor(availW / cellW));
  var rowCount = Math.ceil(totalCells / maxPerRow);

  for (var r = 0; r < rowCount; r++) {
    var startCell = r * maxPerRow;
    var endCell = Math.min(startCell + maxPerRow, totalCells);

    // Beat labels
    var beatRow = document.createElement('div');
    beatRow.className = 'lane-beat-labels';
    for (var i = startCell; i < endCell; i++) {
      var bl = document.createElement('div');
      bl.className = 'lane-blabel ' + lblClass;
      if (isNorm) {
        // Normal: 32 cells/bar → bar@0, 1/2@16, 1/4@8, 1/8@4, 1/16@2
        if (i % 32 === 0)      { bl.textContent = 'BAR ' + (Math.floor(i / 32) + 1); bl.classList.add('bar'); }
        else if (i % 16 === 0) { bl.textContent = '1/2'; bl.classList.add('half'); }
        else if (i % 8 === 0)  { bl.textContent = '1/4'; bl.classList.add('quarter'); }
        else if (i % 4 === 0)  { bl.textContent = '1/8'; bl.classList.add('eighth'); }
      } else {
        // Triplet: 48 cells/bar → bar@0, 1/2@24, 1/4@12, 1/8t@6, 1/16t@3
        if (i % 48 === 0)      { bl.textContent = 'BAR ' + (Math.floor(i / 48) + 1); bl.classList.add('bar'); }
        else if (i % 24 === 0) { bl.textContent = '1/2'; bl.classList.add('half'); }
        else if (i % 12 === 0) { bl.textContent = '1/4'; bl.classList.add('quarter'); }
        else if (i % 6 === 0)  { bl.textContent = '1/8t'; bl.classList.add('eighth'); }
        else if (i % 3 === 0)  { bl.textContent = '1/16t'; bl.classList.add('triplet-div'); }
      }
      beatRow.appendChild(bl);
    }
    wrap.appendChild(beatRow);

    // Cell row
    var row = document.createElement('div');
    row.className = 'lane-row';
    for (var i = startCell; i < endCell; i++) {
      var tickPos = i * tickMul;
      var cell = document.createElement('div');
      cell.className = cellClass + ' ' + CCLASS[c];
      cell.id = (isNorm ? 'nc_' : 'tc_') + c + '_' + i;

      // Beat mark & alt
      if (isNorm) {
        if (i % 8 === 0) cell.classList.add('beat-mark');
        if (Math.floor(i / 4) % 2 === 1) cell.classList.add('beat-alt');
      } else {
        if (i % 12 === 0) cell.classList.add('beat-mark');
        if (Math.floor(i / 6) % 2 === 1) cell.classList.add('beat-alt');
      }

      var isInactive = tickPos >= ch.count;
      if (isInactive) {
        cell.classList.add('inactive');
      } else {
        var step = ch.steps[tickPos];
        var isBlocked = blocked[tickPos];
        if (step && step.on) {
          var durMatchesLane = isNorm ? isNormalDur(step.dur) : isTripletDur(step.dur);
          if (durMatchesLane) {
            cell.classList.add('on');
            // Two-row display: wave symbol + dur label
            var waveSpan = document.createElement('span');
            waveSpan.className = 'cell-wave';
            waveSpan.textContent = WAVE_SYM[step.wave] || '\u25CF';
            var durSpan = document.createElement('span');
            durSpan.className = 'cell-dur';
            durSpan.textContent = durLabel(step.dur);
            cell.appendChild(waveSpan);
            cell.appendChild(durSpan);
            cell.style.color = '#fff';
            if (ch.selectedStep === tickPos) {
              cell.classList.add('selected');
            }
            // Draggable
            cell.draggable = true;
            cell.setAttribute('data-ch', c);
            cell.setAttribute('data-tick', tickPos);
            cell.setAttribute('data-lane', laneType);
          } else {
            // Note exists but belongs to other lane → show as blocked
            cell.classList.add('blocked');
            cell.textContent = '\u2500';
            cell.style.color = 'var(--color-ch' + c + ')';
            cell.style.opacity = '0.4';
          }
        } else if (isBlocked) {
          cell.classList.add('blocked');
          cell.textContent = '\u2500';
          cell.style.color = 'var(--color-ch' + c + ')';
          cell.style.opacity = '0.5';
        } else {
          // Empty cell: droppable target
          cell.setAttribute('data-ch', c);
          cell.setAttribute('data-tick', tickPos);
          cell.setAttribute('data-lane', laneType);
        }
      }

      cell.addEventListener('click', (function(c, tickPos, laneType) {
        return function(e) { laneCellClick(c, tickPos, laneType, e); };
      })(c, tickPos, laneType));
      cell.addEventListener('dblclick', (function(c, tickPos, laneType) {
        return function(e) { laneCellDblClick(c, tickPos, laneType); };
      })(c, tickPos, laneType));

      // Drag & drop
      cell.addEventListener('dragstart', (function(c, tickPos, laneType) {
        return function(e) { gridDragStart(e, c, tickPos, laneType); };
      })(c, tickPos, laneType));
      cell.addEventListener('dragover', function(e) { e.preventDefault(); e.currentTarget.classList.add('drag-over'); });
      cell.addEventListener('dragleave', function(e) { e.currentTarget.classList.remove('drag-over'); });
      cell.addEventListener('drop', (function(c, tickPos, laneType) {
        return function(e) { gridDrop(e, c, tickPos, laneType); };
      })(c, tickPos, laneType));
      cell.addEventListener('dragend', function(e) {
        document.querySelectorAll('.drag-over,.drag-source').forEach(function(el) {
          el.classList.remove('drag-over','drag-source');
        });
      });

      row.appendChild(cell);
    }
    wrap.appendChild(row);
  }

  return wrap;
}

// Keep old name as alias for backward compatibility in calls
function renderUnifiedGrid() { renderSplitGrid(); }

// ============================================================
//  RT SONG LANE
// ============================================================
function nextRTPatternName() {
  var used = {};
  rtPatterns.forEach(function(p) { used[p.name] = true; });
  for (var i = 0; i < 26; i++) {
    var name = 'R' + String.fromCharCode(65 + i);
    if (!used[name]) return name;
  }
  // If RA-RZ all used, go RA2, RB2...
  for (var n = 2; n <= 99; n++) {
    for (var i = 0; i < 26; i++) {
      var name = 'R' + String.fromCharCode(65 + i) + n;
      if (!used[name]) return name;
    }
  }
  return 'R' + (rtPatterns.length + 1);
}

function nextRTCopyName(srcPat) {
  var base = srcPat.baseName || srcPat.name || 'RA';
  var used = {};
  rtPatterns.forEach(function(p) { used[p.name] = true; });
  for (var n = 1; n <= 99; n++) {
    var candidate = base + n;
    if (!used[candidate]) return { name: candidate, baseName: base, varySuffix: '' + n };
  }
  return { name: base + '_' + (rtPatterns.length + 1), baseName: base, varySuffix: '_' + (rtPatterns.length + 1) };
}

function renderRTSongLane() {
  var wrap = document.getElementById('rtSongLane');
  if (!wrap) return;
  wrap.innerHTML = '';

  rtSong.forEach(function(entry, idx) {
    var pat = rtPatterns[entry.patIdx];
    var cell = document.createElement('div');
    cell.className = 'song-cell rt-song-cell';
    if (entry.sectionColor && entry.sectionColor !== 'none') cell.classList.add('sec-' + entry.sectionColor);
    if (idx === selectedRTSongCell) cell.classList.add('active');
    if (idx === songPlayhead) cell.classList.add('song-playhead');
    cell.draggable = true;

    var nameEl = document.createElement('div');
    nameEl.className = 'sc-name';
    nameEl.style.color = 'var(--color-rt)';
    nameEl.textContent = pat ? pat.name : '?';

    var repeatWrap = document.createElement('div');
    repeatWrap.className = 'sc-repeat-wrap';
    var repeatLabel = document.createElement('span');
    repeatLabel.className = 'sc-repeat-label';
    repeatLabel.textContent = 'x';
    var repeatInput = document.createElement('input');
    repeatInput.className = 'sc-repeat-input';
    repeatInput.type = 'number';
    repeatInput.min = 1; repeatInput.max = 99;
    repeatInput.value = entry.repeat;
    repeatInput.addEventListener('click', function(e) { e.stopPropagation(); });
    repeatInput.addEventListener('change', (function(ent) {
      return function() { ent.repeat = Math.max(1, Math.min(99, parseInt(this.value) || 1)); this.value = ent.repeat; };
    })(entry));
    repeatWrap.appendChild(repeatLabel);
    repeatWrap.appendChild(repeatInput);

    // Delete button
    var delBtn = document.createElement('div');
    delBtn.className = 'sc-delete';
    delBtn.textContent = '\u00D7';
    delBtn.addEventListener('click', (function(i) {
      return function(e) {
        e.stopPropagation();
        if (rtSong.length <= 1) return;
        rtSong.splice(i, 1);
        if (selectedRTSongCell >= rtSong.length) selectedRTSongCell = rtSong.length - 1;
        if (songPlayhead >= rtSong.length) songPlayhead = Math.min(songPlayhead, rtSong.length - 1);
        renderRTSongLane();
      };
    })(idx));

    // Click: select RT cell
    cell.addEventListener('click', (function(i) {
      return function(e) {
        if (e.target.classList.contains('sc-delete') || e.target.classList.contains('sc-repeat-input')) return;
        selectRTSongPosition(i);
      };
    })(idx));

    // Double-click name: rename RT pattern
    nameEl.addEventListener('dblclick', (function(ent) {
      return function(e) {
        e.stopPropagation();
        var p = rtPatterns[ent.patIdx];
        if (!p) return;
        var newName = prompt('Rename RT pattern "' + p.name + '" to:', p.name);
        if (newName && newName.trim().length > 0 && newName.trim() !== p.name) {
          p.name = newName.trim(); p.baseName = newName.trim(); p.varySuffix = '';
          renderRTSongLane(); renderRTPatternSelect(); renderPatternPool();
        }
      };
    })(entry));

    // Right-click: section color
    cell.addEventListener('contextmenu', (function(ent) {
      return function(e) {
        e.preventDefault();
        var cur = ent.sectionColor || 'none';
        var ci = SEC_COLORS.indexOf(cur);
        ent.sectionColor = SEC_COLORS[(ci + 1) % SEC_COLORS.length];
        renderRTSongLane();
      };
    })(entry));

    // D&D
    cell.addEventListener('dragstart', (function(i) {
      return function(e) {
        e.dataTransfer.setData('text/plain', JSON.stringify({ type: 'rt-song', idx: i }));
        e.dataTransfer.effectAllowed = 'move';
        setTimeout(function() { cell.classList.add('drag-source'); }, 0);
      };
    })(idx));
    cell.addEventListener('dragend', function() {
      document.querySelectorAll('.drag-source,.drag-over-left,.drag-over-right').forEach(function(el) {
        el.classList.remove('drag-source', 'drag-over-left', 'drag-over-right');
      });
    });
    cell.addEventListener('dragover', function(e) {
      e.preventDefault();
      var rect = cell.getBoundingClientRect();
      cell.classList.remove('drag-over-left', 'drag-over-right');
      cell.classList.add(e.clientX < rect.left + rect.width / 2 ? 'drag-over-left' : 'drag-over-right');
    });
    cell.addEventListener('dragleave', function() { cell.classList.remove('drag-over-left', 'drag-over-right'); });
    cell.addEventListener('drop', (function(dropIdx) {
      return function(e) {
        e.preventDefault();
        cell.classList.remove('drag-over-left', 'drag-over-right');
        try {
          var data = JSON.parse(e.dataTransfer.getData('text/plain'));
          if (data.type !== 'rt-song') return;
          var rect = cell.getBoundingClientRect();
          var insertAfter = e.clientX >= rect.left + rect.width / 2;
          var fromIdx = data.idx;
          if (fromIdx === dropIdx) return;
          var item = rtSong.splice(fromIdx, 1)[0];
          var toIdx = fromIdx < dropIdx ? (insertAfter ? dropIdx : dropIdx - 1) : (insertAfter ? dropIdx + 1 : dropIdx);
          rtSong.splice(toIdx, 0, item);
          selectedRTSongCell = toIdx;
          renderRTSongLane();
        } catch(ex) {}
      };
    })(idx));

    cell.appendChild(delBtn);
    cell.appendChild(nameEl);
    cell.appendChild(repeatWrap);
    wrap.appendChild(cell);
  });

  // Add button
  var addBtn = document.createElement('div');
  addBtn.className = 'song-add';
  addBtn.style.borderColor = 'var(--color-rt)';
  addBtn.textContent = '+';
  addBtn.addEventListener('click', function() {
    var name = nextRTPatternName();
    var pat = makeRTPattern(name);
    pat.patternLength = patterns[currentPatternIdx >= 0 ? currentPatternIdx : 0].patternLength || 128;
    pat.channels[0].count = pat.patternLength;
    rtPatterns.push(pat);
    rtSong.push({ patIdx: rtPatterns.length - 1, repeat: 1 });
    selectedRTSongCell = rtSong.length - 1;
    switchToRTPattern(rtPatterns.length - 1);
    renderPatternPool();
  });
  wrap.appendChild(addBtn);
  renderRTPatternSelect();
}

function renderRTPatternSelect() {
  var sel = document.getElementById('rtPatSelect');
  if (!sel) return;
  sel.innerHTML = '';
  rtPatterns.forEach(function(p, idx) {
    var opt = document.createElement('option');
    opt.value = idx;
    opt.textContent = p.name;
    if (idx === currentRTPatternIdx) opt.selected = true;
    sel.appendChild(opt);
  });
}

// ============================================================
//  RT CHANNEL BLOCK & GRID
// ============================================================
function buildRTUI() {
  var max = getMax();
  var avail = getAvailableDurs();
  rtState.forEach(function(ch) {
    while (ch.steps.length < max) ch.steps.push(makeStep());
    if (ch.count > max) ch.count = max;
    if (avail.indexOf(ch.brushDur) < 0) ch.brushDur = avail[0];
  });
  buildRTChannelBlock();
  renderRTGrid();
}

function buildRTChannelBlock() {
  var avail = getAvailableDurs();
  var wrap = document.getElementById('rtChBlocks');
  if (!wrap) return;
  wrap.innerHTML = '';

  var ch = rtState[0];
  var block = document.createElement('div');
  block.className = 'ch-block';
  block.style.borderColor = 'color-mix(in srgb, var(--color-rt) 25%, var(--step-bg))';

  var smoothDisabled = SMOOTH_NO_EFFECT.indexOf(ch.brushWave) >= 0;
  var smoothClass = ch.smooth && !smoothDisabled ? 'wave-mod active-smooth' : (smoothDisabled ? 'wave-mod disabled' : 'wave-mod');
  var bipolarClass = ch.bipolar ? 'wave-mod active-bipolar' : 'wave-mod';

  var waveOptions = WAVEFORMS.map(function(w) {
    return '<option value="' + w.id + '"' + (ch.brushWave === w.id ? ' selected' : '') + '>' + w.symbol + ' ' + w.name + '</option>';
  }).join('');
  var durOptions = avail.map(function(d) {
    return '<option value="' + d + '"' + (ch.brushDur === d ? ' selected' : '') + '>' + durLabel(d) + '</option>';
  }).join('');

  var max = getMax();
  var audio = getRTAudio();

  block.innerHTML =
    '<div class="ch-header">' +
      '<div class="ch-name crt">' + RT_CNAME + '</div>' +
      '<button class="audio-mode-btn' + (chMute[3] ? ' muted' : '') + '" onclick="toggleMute(3)" style="margin-left:4px;font-size:0.7em;' + (chMute[3] ? 'background:#e11d48;color:#fff' : '') + '" title="Mute/Unmute">M</button>' +
      '<div class="steps-ctrl">' +
        '<button class="sc-btn" onclick="adjRTCount(-1)">\u2212</button>' +
        '<input class="sc-input" type="number" id="scrt" value="' + ch.count + '" min="1" max="' + max + '" onchange="setRTCount(this.value)">' +
        '<button class="sc-btn" onclick="adjRTCount(1)">+</button>' +
        '<span style="font-size:0.6em;color:#555;margin-left:2px">steps</span>' +
      '</div>' +
      '<div class="midi-cfg">' +
        '<label>NOTE</label><input type="number" id="noterT" value="' + ch.note + '" min="0" max="127" onchange="rtState[0].note=parseInt(this.value)">' +
        '<label>MIDI CH</label><input type="number" id="michrt" value="' + ch.mich + '" min="1" max="16" onchange="rtState[0].mich=parseInt(this.value)">' +
      '</div>' +
    '</div>' +
    '<div class="ch-wave-row">' +
      '<canvas class="wave-preview" id="wvrt" width="80" height="26"></canvas>' +
      '<span class="sel-label" id="slabelrt">DEFAULT</span>' +
      '<select class="wave-sel" id="wselrt" onchange="onRTWaveSelect(this.value)">' + waveOptions + '</select>' +
      '<select class="wave-sel dur-sel" id="dselrt" onchange="onRTDurSelect(parseInt(this.value))">' + durOptions + '</select>' +
      '<button class="' + smoothClass + '" id="wsmoothrt" onclick="toggleRTSmooth()">S</button>' +
      '<button class="' + bipolarClass + '" id="wbipolarrt" onclick="toggleRTBipolar()">B</button>' +
      '<div class="freq-wrap">' +
        '<button class="audio-mode-btn' + (globalAudioMode[3] ? '' : ' local') + '" onclick="toggleAudioMode(3)">' + (globalAudioMode[3] ? 'G' : 'L') + '</button>' +
        '<span class="freq-label">Hz</span>' +
        '<input type="range" class="freq-range" id="freqrt" min="50" max="2000" value="' + audio.freq + '" oninput="setRTFreq(this.value)">' +
        '<input type="number" class="freq-input" id="freqvrt" min="50" max="2000" value="' + audio.freq + '" onchange="setRTFreqInput(this.value)">' +
      '</div>' +
      '<div class="vol-wrap">' +
        '<span class="vol-label">VOL</span>' +
        '<input type="range" class="vol-range" id="volrt" min="0" max="100" value="' + Math.round(audio.volume * 100) + '" oninput="setRTVolume(this.value)">' +
        '<span class="vol-value" id="volvrt">' + Math.round(audio.volume * 100) + '</span>' +
      '</div>' +
      '<div class="pan-wrap">' +
        '<span class="pan-label">PAN</span>' +
        '<input type="range" class="pan-range" id="panrt" min="-100" max="100" value="' + audio.pan + '" oninput="setRTPan(this.value)">' +
        '<span class="pan-value" id="panvrt">' + (audio.pan === 0 ? 'C' : (audio.pan < 0 ? 'L' + Math.abs(audio.pan) : 'R' + audio.pan)) + '</span>' +
      '</div>' +
    '</div>' +
    '<div class="ev-chain-wrap" id="evchainrt"></div>' +
    '<button class="fill-gap-btn" onclick="fillRTGaps()" title="Fill gaps with Low">FILL GAP</button>' +
    '<button class="fill-gap-btn" onclick="clearRTChannel()" title="Clear RT channel" style="margin-left:4px;background:#e11d48;color:#fff">CLR</button>' +
    '<button class="fill-gap-btn" onclick="openS2SImport(0, true)" title="Import from Shape\u2192Sound" style="margin-left:4px;background:var(--btn-score);color:var(--btn-score-tx, var(--btn-text))">&#8593; S2S</button>';

  wrap.appendChild(block);
  renderRTEventChain();
  drawRTWaveformPreview();
}

// RT event chain (uses rtState[0])
function getRTEventChain() {
  var ch = rtState[0];
  var events = [];
  for (var i = 0; i < ch.count; i++) {
    if (ch.steps[i] && ch.steps[i].on) events.push({ step: i, wave: ch.steps[i].wave, dur: ch.steps[i].dur });
  }
  return events;
}

function renderRTEventChain() {
  var wrap = document.getElementById('evchainrt');
  if (!wrap) return;
  wrap.innerHTML = '';
  var ch = rtState[0];
  var events = getRTEventChain();

  events.forEach(function(ev, idx) {
    var el = document.createElement('div');
    el.className = 'ev-cell crt';
    if (ch.selectedStep === ev.step) el.classList.add('selected');
    if (rtRangeSelection.steps.indexOf(ev.step) >= 0) el.classList.add('range-selected');
    el.innerHTML =
      '<div class="ev-wave" data-area="wave">' + WAVE_SYM[ev.wave] + '</div>' +
      '<div class="ev-dur" data-area="dur">' + durLabel(ev.dur) + '</div>';
    el.addEventListener('click', (function(step) {
      return function(event) { rtEvChainSelect(step, event); };
    })(ev.step));
    el.addEventListener('dblclick', (function(step) {
      return function(event) { rtEvChainClick(step, event); };
    })(ev.step));
    wrap.appendChild(el);
  });

  // Add button
  var nextFree = getRTNextFreeStep();
  var addBtn = document.createElement('div');
  addBtn.className = 'ev-add';
  if (nextFree < 0 || nextFree >= ch.count) {
    addBtn.classList.add('disabled');
    addBtn.textContent = '\u00B7';
  } else {
    addBtn.textContent = '+';
    addBtn.addEventListener('click', function() { addRTEventAtEnd(); });
  }
  wrap.appendChild(addBtn);
}

function getRTNextFreeStep() {
  var ch = rtState[0];
  var blocked = computeBlocked(ch);
  var gridStep = isTripletDur(ch.brushDur) ? 2 : 3;
  var start = 0;
  for (var i = ch.count - 1; i >= 0; i--) {
    if (ch.steps[i] && ch.steps[i].on) { start = i + Math.round(durToSteps(ch.steps[i].dur)); break; }
    if (blocked[i]) continue;
  }
  for (var pos = start; pos < ch.count; pos++) {
    if (pos % gridStep !== 0) continue;
    if (ch.steps[pos] && ch.steps[pos].on) continue;
    if (blocked[pos]) continue;
    return pos;
  }
  return -1;
}

function addRTEventAtEnd() {
  var ch = rtState[0];
  var nextFree = getRTNextFreeStep();
  if (nextFree < 0 || nextFree >= ch.count) return;
  var step = ch.steps[nextFree];
  step.on = true; step.wave = ch.brushWave; step.dur = ch.brushDur;
  var avail = getAvailableDurs();
  var span = durToSteps(step.dur);
  while (nextFree + span > ch.count) {
    var idx = avail.indexOf(step.dur);
    if (idx <= 0) { step.on = false; return; }
    step.dur = avail[idx - 1]; span = durToSteps(step.dur);
  }
  for (var j = 1; j < span && nextFree + j < ch.count; j++) ch.steps[nextFree + j].on = false;
  selectRTStep(nextFree);
}

function repackRTEvents() {
  var ch = rtState[0];
  var events = [];
  for (var i = 0; i < ch.count; i++) {
    if (ch.steps[i] && ch.steps[i].on) events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur });
  }
  for (var i = 0; i < ch.steps.length; i++) { ch.steps[i].on = false; ch.steps[i].wave = 'triangle'; ch.steps[i].dur = 16; }
  var pos = 0;
  for (var e = 0; e < events.length; e++) {
    var span = durToSteps(events[e].dur);
    if (pos + span > ch.count) {
      var avail = getAvailableDurs();
      var fitted = false;
      for (var a = 0; a < avail.length; a++) {
        if (pos + durToSteps(avail[a]) <= ch.count) { events[e].dur = avail[a]; span = durToSteps(avail[a]); fitted = true; break; }
      }
      if (!fitted) break;
    }
    ch.steps[pos].on = true; ch.steps[pos].wave = events[e].wave; ch.steps[pos].dur = events[e].dur;
    pos += span;
  }
}

function fillRTGaps() {
  var ch = rtState[0];
  var events = getRTEventChain();
  if (events.length === 0) return;

  var avail = getAvailableDurs();
  var gaps = [];

  for (var ei = 0; ei < events.length; ei++) {
    var evEnd = events[ei].step + durToSteps(events[ei].dur);
    var nextStart = (ei + 1 < events.length) ? events[ei + 1].step : ch.count;
    if (evEnd < nextStart) gaps.push({ start: evEnd, len: nextStart - evEnd });
  }
  if (events[0].step > 0) gaps.unshift({ start: 0, len: events[0].step });

  gaps.forEach(function(gap) {
    var pos = gap.start;
    var remaining = gap.len;
    while (remaining > 0) {
      var filled = false;
      for (var a = avail.length - 1; a >= 0; a--) {
        var span = durToSteps(avail[a]);
        var onNorm = (pos % 3 === 0) && isNormalDur(avail[a]);
        var onTrip = (pos % 2 === 0) && isTripletDur(avail[a]);
        if ((onNorm || onTrip) && span <= remaining) {
          ch.steps[pos].on = true;
          ch.steps[pos].wave = 'low';
          ch.steps[pos].dur = avail[a];
          pos += span;
          remaining -= span;
          filled = true;
          break;
        }
      }
      if (!filled) { pos++; remaining--; }
    }
  });
  renderRTGrid(); renderRTEventChain();
}

// RT step selection
function selectRTStep(s) {
  var ch = rtState[0];
  ch.selectedStep = s;
  var step = ch.steps[s];
  // Sync CH block selectors
  var wSelEl = document.getElementById('wselrt');
  var dSelEl = document.getElementById('dselrt');
  if (wSelEl) wSelEl.value = step.wave;
  if (dSelEl) dSelEl.value = step.dur;
  var label = document.getElementById('slabelrt');
  if (label) { label.textContent = 'STEP ' + (s + 1); label.className = 'sel-label active'; }
  drawRTWaveformPreview();
  renderRTGrid();
  renderRTEventChain();
  // Sync grid-inline selectors AFTER renderRTGrid (which recreates them)
  var gwSelEl = document.getElementById('gwselrt');
  var gdSelEl = document.getElementById('gdselrt');
  if (gwSelEl) gwSelEl.value = step.wave;
  if (gdSelEl) gdSelEl.value = step.dur;
}

function deselectRTStep() {
  var ch = rtState[0];
  ch.selectedStep = -1;
  var wEl = document.getElementById('wselrt'); if (wEl) wEl.value = ch.brushWave;
  var dEl = document.getElementById('dselrt'); if (dEl) dEl.value = ch.brushDur;
  var gwEl = document.getElementById('gwselrt'); if (gwEl) gwEl.value = ch.brushWave;
  var gdEl = document.getElementById('gdselrt'); if (gdEl) gdEl.value = ch.brushDur;
  var label = document.getElementById('slabelrt');
  if (label) { label.textContent = 'DEFAULT'; label.className = 'sel-label'; }
  drawRTWaveformPreview();
}

function onRTWaveSelect(id) {
  var ch = rtState[0];
  if (ch.selectedStep >= 0 && ch.steps[ch.selectedStep] && ch.steps[ch.selectedStep].on) {
    ch.steps[ch.selectedStep].wave = id;
  } else { ch.brushWave = id; }
  drawRTWaveformPreview(); renderRTGrid(); renderRTEventChain();
}

function onRTDurSelect(dur) {
  var ch = rtState[0];
  if (ch.selectedStep >= 0 && ch.steps[ch.selectedStep] && ch.steps[ch.selectedStep].on) {
    var s = ch.selectedStep;
    var compatible = (isNormalDur(dur) && s % 3 === 0) || (isTripletDur(dur) && s % 2 === 0);
    if (!compatible) { document.getElementById('dselrt').value = ch.steps[s].dur; return; }
    var evBefore = getRTEventChain();
    var evIdx = -1;
    for (var ei = 0; ei < evBefore.length; ei++) { if (evBefore[ei].step === s) { evIdx = ei; break; } }
    ch.steps[s].dur = dur;
    repackRTEvents();
    var evAfter = getRTEventChain();
    if (evIdx >= 0 && evIdx < evAfter.length) selectRTStep(evAfter[evIdx].step);
    else { renderRTGrid(); renderRTEventChain(); }
  } else { ch.brushDur = dur; }
}

function setRTFreq(val) { var v = Math.max(50, Math.min(2000, parseInt(val) || 50)); if (globalAudioMode[3]) rtGlobalAudio.freq = v; else rtState[0].freq = v; var el = document.getElementById('freqvrt'); if (el) el.value = v; }
function setRTFreqInput(val) { var v = Math.max(50, Math.min(2000, parseInt(val) || 50)); if (globalAudioMode[3]) rtGlobalAudio.freq = v; else rtState[0].freq = v; var el = document.getElementById('freqrt'); if (el) el.value = v; var el2 = document.getElementById('freqvrt'); if (el2) el2.value = v; }
function setRTVolume(val) { var v = parseInt(val) / 100; if (globalAudioMode[3]) rtGlobalAudio.volume = v; else rtState[0].volume = v; var el = document.getElementById('volvrt'); if (el) el.textContent = val; }
function setRTPan(val) { var v = Math.max(-100, Math.min(100, parseInt(val) || 0)); if (globalAudioMode[3]) rtGlobalAudio.pan = v; else rtState[0].pan = v; var el = document.getElementById('panvrt'); if (el) el.textContent = v === 0 ? 'C' : (v < 0 ? 'L' + Math.abs(v) : 'R' + v); }
function toggleRTSmooth() { if (SMOOTH_NO_EFFECT.indexOf(rtState[0].brushWave) >= 0) return; rtState[0].smooth = !rtState[0].smooth; drawRTWaveformPreview(); }
function toggleRTBipolar() { rtState[0].bipolar = !rtState[0].bipolar; drawRTWaveformPreview(); }
function adjRTCount(d) { var v = Math.max(1, Math.min(getMax(), rtState[0].count + d)); rtState[0].count = v; rtPatterns[currentRTPatternIdx].patternLength = v; var el = document.getElementById('scrt'); if (el) el.value = v; buildRTUI(); }
function setRTCount(val) { var v = Math.max(1, Math.min(getMax(), parseInt(val) || 1)); rtState[0].count = v; rtPatterns[currentRTPatternIdx].patternLength = v; buildRTUI(); }

function drawRTWaveformPreview() {
  var canvas = document.getElementById('wvrt');
  if (!canvas) return;
  var ch = rtState[0];
  var wave = ch.selectedStep >= 0 && ch.steps[ch.selectedStep] && ch.steps[ch.selectedStep].on ? ch.steps[ch.selectedStep].wave : ch.brushWave;
  var ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = RT_COLOR; ctx.lineWidth = 1.5;
  ctx.beginPath();
  for (var x = 0; x < canvas.width; x++) {
    var t = x / canvas.width;
    var y = getLFOValue(wave, ch.smooth, t);
    if (ch.bipolar) y = y * 2 - 1;
    var py = canvas.height - y * canvas.height * 0.8 - canvas.height * 0.1;
    if (x === 0) ctx.moveTo(x, py); else ctx.lineTo(x, py);
  }
  ctx.stroke();
}

function rtEvChainSelect(step, event) {
  var ch = rtState[0];
  if (!ch.steps[step] || !ch.steps[step].on) return;

  if (event.shiftKey && ch.selectedStep >= 0 && rtRangeSelection.steps.length > 0) {
    var from = ch.selectedStep;
    var to = step;
    if (from > to) { var tmp = from; from = to; to = tmp; }
    rtRangeSelection.steps = [];
    for (var i = from; i <= to; i++) {
      if (ch.steps[i] && ch.steps[i].on) rtRangeSelection.steps.push(i);
    }
    renderRTGrid(); renderRTEventChain();
    document.getElementById('status').textContent = rtRangeSelection.steps.length + ' RT cells selected (Delete to remove)';
    return;
  }

  rtRangeSelection.steps = [step];
  selectRTStep(step);
}

function rtEvChainClick(step, event) {
  var area = event.target.getAttribute('data-area');
  var ch = rtState[0];
  var s = ch.steps[step];
  if (!s || !s.on) return;
  if (area === 'wave') {
    var idx = WAVE_IDS.indexOf(s.wave);
    s.wave = WAVE_IDS[(idx + 1) % WAVE_IDS.length];
    selectRTStep(step);
  } else if (area === 'dur') {
    var evBefore = getRTEventChain();
    var evIdx = -1;
    for (var ei = 0; ei < evBefore.length; ei++) { if (evBefore[ei].step === step) { evIdx = ei; break; } }
    var avail = getAvailableDurs();
    var posOnNorm = (step % 3 === 0), posOnTrip = (step % 2 === 0);
    var compatAvail = avail.filter(function(d) { return (posOnNorm && isNormalDur(d)) || (posOnTrip && isTripletDur(d)); });
    if (compatAvail.length === 0) compatAvail = avail;
    var curIdx = compatAvail.indexOf(s.dur); if (curIdx < 0) curIdx = 0;
    s.dur = compatAvail[(curIdx + 1) % compatAvail.length];
    repackRTEvents();
    var evAfter = getRTEventChain();
    if (evIdx >= 0 && evIdx < evAfter.length) selectRTStep(evAfter[evIdx].step);
    else buildRTUI();
  } else { selectRTStep(step); }
}

// ============================================================
//  RT GRID RENDERING (1 channel: normal + triplet lanes)
// ============================================================
function renderRTGrid() {
  var gridEl = document.getElementById('rtGrid');
  if (!gridEl) return;
  gridEl.innerHTML = '';

  var ch = rtState[0];
  var blocked = computeBlocked(ch);

  var chDiv = document.createElement('div');
  chDiv.className = 'split-channel';

  var chLabel = document.createElement('div');
  chLabel.className = 'split-ch-label';
  var dot = document.createElement('span');
  dot.className = 'ch-dot';
  dot.style.background = 'var(--color-rt)';
  chLabel.appendChild(dot);
  var nameSpan = document.createElement('span');
  nameSpan.textContent = RT_CNAME;
  chLabel.appendChild(nameSpan);

  // Brush selectors (dual-purpose: brush when no selection, edit when step selected)
  var brushWrap = document.createElement('span');
  brushWrap.style.cssText = 'margin-left:10px;display:inline-flex;gap:4px;align-items:center;';
  var waveSel = document.createElement('select');
  waveSel.id = 'gwselrt';
  waveSel.style.cssText = 'background:var(--input-bg);border:1px solid var(--border);color:var(--text);padding:1px 3px;border-radius:3px;font-size:0.75em;';
  WAVEFORMS.forEach(function(w) {
    var opt = document.createElement('option');
    opt.value = w.id; opt.textContent = w.symbol + ' ' + w.name;
    if (ch.brushWave === w.id) opt.selected = true;
    waveSel.appendChild(opt);
  });
  waveSel.addEventListener('change', function() { onRTWaveSelect(this.value); });
  var durSel = document.createElement('select');
  durSel.id = 'gdselrt';
  durSel.style.cssText = 'background:var(--input-bg);border:1px solid var(--border);color:var(--text);padding:1px 3px;border-radius:3px;font-size:0.75em;';
  getAvailableDurs().forEach(function(d) {
    var opt = document.createElement('option');
    opt.value = d; opt.textContent = durLabel(d);
    if (ch.brushDur === d) opt.selected = true;
    durSel.appendChild(opt);
  });
  durSel.addEventListener('change', function() { onRTDurSelect(parseInt(this.value)); });
  var addBtn = document.createElement('button');
  addBtn.textContent = '+';
  addBtn.style.cssText = 'background:var(--color-rt);color:#fff;border:none;border-radius:3px;padding:1px 6px;font-size:0.75em;cursor:pointer;';
  addBtn.addEventListener('click', function() { addRTEventAtEnd(); });
  brushWrap.appendChild(waveSel);
  brushWrap.appendChild(durSel);
  brushWrap.appendChild(addBtn);
  chLabel.appendChild(brushWrap);
  chDiv.appendChild(chLabel);

  chDiv.appendChild(buildRTLane(ch, blocked, 'normal'));
  chDiv.appendChild(buildRTLane(ch, blocked, 'triplet'));
  gridEl.appendChild(chDiv);
}

function buildRTLane(ch, blocked, laneType) {
  var isNorm = (laneType === 'normal');
  var totalCells = isNorm ? getLaneNCells() : getLaneTCells();
  var tickMul = isNorm ? 3 : 2;
  var cellClass = isNorm ? 'n-cell' : 't-cell';
  var lblClass = isNorm ? 'n-lbl' : 't-lbl';
  var cellW = isNorm ? N_CELL_W : T_CELL_W;

  var wrap = document.createElement('div');
  wrap.className = 'lane-wrap';
  var ll = document.createElement('div');
  ll.className = 'lane-label';
  ll.textContent = isNorm ? 'NORMAL' : 'TRIPLET';
  wrap.appendChild(ll);

  var container = document.getElementById('rtGrid');
  var availW = container ? container.clientWidth : 900;
  var maxPerRow = Math.max(4, Math.floor(availW / cellW));
  var rowCount = Math.ceil(totalCells / maxPerRow);

  for (var r = 0; r < rowCount; r++) {
    var startCell = r * maxPerRow;
    var endCell = Math.min(startCell + maxPerRow, totalCells);

    var beatRow = document.createElement('div');
    beatRow.className = 'lane-beat-labels';
    for (var i = startCell; i < endCell; i++) {
      var bl = document.createElement('div');
      bl.className = 'lane-blabel ' + lblClass;
      if (isNorm) {
        if (i % 32 === 0) { bl.textContent = 'BAR ' + (Math.floor(i / 32) + 1); bl.classList.add('bar'); }
        else if (i % 16 === 0) { bl.textContent = '1/2'; bl.classList.add('half'); }
        else if (i % 8 === 0) { bl.textContent = '1/4'; bl.classList.add('quarter'); }
        else if (i % 4 === 0) { bl.textContent = '1/8'; bl.classList.add('eighth'); }
      } else {
        if (i % 48 === 0) { bl.textContent = 'BAR ' + (Math.floor(i / 48) + 1); bl.classList.add('bar'); }
        else if (i % 24 === 0) { bl.textContent = '1/2'; bl.classList.add('half'); }
        else if (i % 12 === 0) { bl.textContent = '1/4'; bl.classList.add('quarter'); }
        else if (i % 6 === 0) { bl.textContent = '1/8t'; bl.classList.add('eighth'); }
        else if (i % 3 === 0) { bl.textContent = '1/16t'; bl.classList.add('triplet-div'); }
      }
      beatRow.appendChild(bl);
    }
    wrap.appendChild(beatRow);

    var row = document.createElement('div');
    row.className = 'lane-row';
    for (var i = startCell; i < endCell; i++) {
      var tickPos = i * tickMul;
      var cell = document.createElement('div');
      cell.className = cellClass + ' ' + RT_CCLASS;
      cell.id = (isNorm ? 'rnc_' : 'rtc_') + '0_' + i;

      if (isNorm) {
        if (i % 8 === 0) cell.classList.add('beat-mark');
        if (Math.floor(i / 4) % 2 === 1) cell.classList.add('beat-alt');
      } else {
        if (i % 12 === 0) cell.classList.add('beat-mark');
        if (Math.floor(i / 6) % 2 === 1) cell.classList.add('beat-alt');
      }

      var isInactive = tickPos >= ch.count;
      if (isInactive) {
        cell.classList.add('inactive');
      } else {
        var step = ch.steps[tickPos];
        var isBlocked = blocked[tickPos];
        if (step && step.on) {
          var durMatchesLane = isNorm ? isNormalDur(step.dur) : isTripletDur(step.dur);
          if (durMatchesLane) {
            cell.classList.add('on');
            var waveSpan = document.createElement('span');
            waveSpan.className = 'cell-wave'; waveSpan.textContent = WAVE_SYM[step.wave] || '\u25CF';
            var durSpan = document.createElement('span');
            durSpan.className = 'cell-dur'; durSpan.textContent = durLabel(step.dur);
            cell.appendChild(waveSpan); cell.appendChild(durSpan);
            cell.style.color = '#fff';
            if (ch.selectedStep === tickPos) cell.classList.add('selected');
            cell.draggable = true;
          } else {
            cell.classList.add('blocked');
            cell.textContent = '\u2500'; cell.style.color = 'var(--color-rt)'; cell.style.opacity = '0.4';
          }
        } else if (isBlocked) {
          cell.classList.add('blocked');
          cell.textContent = '\u2500'; cell.style.color = 'var(--color-rt)'; cell.style.opacity = '0.5';
        }
      }

      cell.addEventListener('click', (function(tickPos, laneType) {
        return function(e) { rtLaneCellClick(tickPos, laneType, e); };
      })(tickPos, laneType));
      cell.addEventListener('dblclick', (function(tickPos, laneType) {
        return function() { rtLaneCellDblClick(tickPos, laneType); };
      })(tickPos, laneType));

      // RT Grid D&D
      cell.addEventListener('dragstart', (function(tickPos, laneType) {
        return function(e) { rtGridDragStart(e, tickPos, laneType); };
      })(tickPos, laneType));
      cell.addEventListener('dragover', function(e) { e.preventDefault(); e.currentTarget.classList.add('drag-over'); });
      cell.addEventListener('dragleave', function(e) { e.currentTarget.classList.remove('drag-over'); });
      cell.addEventListener('drop', (function(tickPos, laneType) {
        return function(e) { rtGridDrop(e, tickPos, laneType); };
      })(tickPos, laneType));
      cell.addEventListener('dragend', function(e) {
        document.querySelectorAll('.drag-over,.drag-source').forEach(function(el) {
          el.classList.remove('drag-over','drag-source');
        });
      });

      row.appendChild(cell);
    }
    wrap.appendChild(row);
  }
  return wrap;
}

function rtLaneCellClick(tickPos, laneType, e) {
  var ch = rtState[0];
  if (tickPos >= ch.count) return;
  var blocked = computeBlocked(ch);
  var step = ch.steps[tickPos];
  if (!step.on && blocked[tickPos]) return;
  if (!step.on) {
    step.on = true; step.wave = ch.brushWave;
    var isNorm = (laneType === 'normal');
    var laneDurs = isNorm ? NORMAL_DURS : TRIPLET_DURS;
    step.dur = laneDurs.indexOf(ch.brushDur) >= 0 ? ch.brushDur : (isNorm ? 16 : 24);
    var span = durToSteps(step.dur);
    while (tickPos + span > ch.count) {
      var idx = laneDurs.indexOf(step.dur);
      if (idx <= 0) { step.dur = laneDurs[0]; break; }
      step.dur = laneDurs[idx - 1]; span = durToSteps(step.dur);
    }
    span = durToSteps(step.dur);
    for (var j = 1; j < span && tickPos + j < ch.count; j++) ch.steps[tickPos + j].on = false;
    selectRTStep(tickPos);
  } else if (ch.selectedStep === tickPos && e && e.target) {
    var rect = e.currentTarget.getBoundingClientRect();
    var clickY = e.clientY - rect.top;
    if (clickY < rect.height / 2) {
      var idx = WAVE_IDS.indexOf(step.wave);
      step.wave = WAVE_IDS[(idx + 1) % WAVE_IDS.length];
      selectRTStep(tickPos);
    } else {
      var isNorm = (laneType === 'normal');
      var laneDurs = isNorm ? NORMAL_DURS : TRIPLET_DURS;
      var curIdx = laneDurs.indexOf(step.dur); if (curIdx < 0) curIdx = 0;
      var evBefore = getRTEventChain();
      var evIdx = -1;
      for (var ei = 0; ei < evBefore.length; ei++) { if (evBefore[ei].step === tickPos) { evIdx = ei; break; } }
      step.dur = laneDurs[(curIdx + 1) % laneDurs.length];
      repackRTEvents();
      var evAfter = getRTEventChain();
      if (evIdx >= 0 && evIdx < evAfter.length) selectRTStep(evAfter[evIdx].step);
      else buildRTUI();
    }
  } else { selectRTStep(tickPos); }
}

function rtLaneCellDblClick(tickPos, laneType) {
  var ch = rtState[0];
  if (tickPos >= ch.count) return;
  var step = ch.steps[tickPos];
  if (step && step.on) { step.on = false; deselectRTStep(); renderRTGrid(); renderRTEventChain(); }
}

// ============================================================
//  LANE CELL CLICK (area-based: top=wave cycle, bottom=dur cycle on selected)
// ============================================================
function laneCellClick(c, tickPos, laneType, e) {
  var ch = state[c];
  if (tickPos >= ch.count) return;

  var blocked = computeBlocked(ch);
  var step = ch.steps[tickPos];

  if (!step.on && blocked[tickPos]) return; // blocked

  if (!step.on) {
    // Turn ON with lane-appropriate duration
    step.on = true;
    step.wave = ch.brushWave;

    var isNorm = (laneType === 'normal');
    var laneDurs = isNorm ? NORMAL_DURS : TRIPLET_DURS;
    if (laneDurs.indexOf(ch.brushDur) >= 0) {
      step.dur = ch.brushDur;
    } else {
      step.dur = isNorm ? 16 : 24;
    }

    var avail = laneDurs;
    var span = durToSteps(step.dur);
    while (tickPos + span > ch.count && avail.indexOf(step.dur) >= 0) {
      var idx = avail.indexOf(step.dur);
      if (idx <= 0) { step.dur = avail[0]; break; }
      step.dur = avail[idx - 1];
      span = durToSteps(step.dur);
    }
    span = durToSteps(step.dur);
    for (var j = 1; j < span && tickPos + j < ch.count; j++) {
      ch.steps[tickPos + j].on = false;
    }
    selectStep(c, tickPos);
  } else if (ch.selectedStep === tickPos && e && e.target) {
    // Already selected: area-based editing
    var rect = e.currentTarget.getBoundingClientRect();
    var clickY = e.clientY - rect.top;
    var midY = rect.height / 2;

    if (clickY < midY) {
      // Top half: cycle wave
      var idx = WAVE_IDS.indexOf(step.wave);
      step.wave = WAVE_IDS[(idx + 1) % WAVE_IDS.length];
      // Sync CH block wave selector
      var wSelEl = document.getElementById('wsel' + c);
      if (wSelEl) wSelEl.value = step.wave;
      updateWaveUI(c);
      selectStep(c, tickPos);
    } else {
      // Bottom half: cycle duration
      var isNorm = (laneType === 'normal');
      var laneDurs = isNorm ? NORMAL_DURS : TRIPLET_DURS;
      var curIdx = laneDurs.indexOf(step.dur);
      if (curIdx < 0) curIdx = 0;

      // Find event index before repack
      var evBefore = getEventChain(c);
      var evIdx = -1;
      for (var ei = 0; ei < evBefore.length; ei++) {
        if (evBefore[ei].step === tickPos) { evIdx = ei; break; }
      }

      step.dur = laneDurs[(curIdx + 1) % laneDurs.length];
      // Sync CH block dur selector
      var dSelEl = document.getElementById('dsel' + c);
      if (dSelEl) dSelEl.value = step.dur;
      // Repack to shift following events
      repackEvents(c);

      // Re-select same event by chain index
      var evAfter = getEventChain(c);
      if (evIdx >= 0 && evIdx < evAfter.length) {
        selectStep(c, evAfter[evIdx].step);
      } else {
        buildUI();
      }
    }
  } else {
    // Click on existing event: just select
    selectStep(c, tickPos);
  }
}

// Double click on grid: toggle off existing event
function laneCellDblClick(c, tickPos, laneType) {
  var ch = state[c];
  if (tickPos >= ch.count) return;
  var step = ch.steps[tickPos];
  if (step && step.on) {
    step.on = false;
    deselectStep(c);
    renderSplitGrid();
    renderEventChain(c);
  }
}

// ============================================================
//  GRID DRAG & DROP
// ============================================================
var gridDragData = null;

function gridDragStart(e, c, tickPos, laneType) {
  var ch = state[c];
  var step = ch.steps[tickPos];
  if (!step || !step.on) { e.preventDefault(); return; }
  gridDragData = { ch: c, tick: tickPos, lane: laneType, wave: step.wave, dur: step.dur };
  e.currentTarget.classList.add('drag-source');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', 'grid-drag');
}

function gridDrop(e, targetCh, targetTick, targetLane) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over');
  if (!gridDragData) return;
  if (gridDragData.ch !== targetCh) return; // Same channel only

  var ch = state[targetCh];
  var srcTick = gridDragData.tick;
  var wave = gridDragData.wave;
  var dur = gridDragData.dur;

  // Check lane compatibility
  var isNorm = (targetLane === 'normal');
  if (isNorm && !isNormalDur(dur)) { gridDragData = null; return; }
  if (!isNorm && !isTripletDur(dur)) { gridDragData = null; return; }

  // Check bounds
  var span = durToSteps(dur);
  if (targetTick + span > ch.count) { gridDragData = null; return; }

  // Clear source
  ch.steps[srcTick].on = false;
  ch.steps[srcTick].wave = 'triangle';
  ch.steps[srcTick].dur = 16;

  // Clear target area
  for (var j = 0; j < span && targetTick + j < ch.count; j++) {
    ch.steps[targetTick + j].on = false;
  }

  // Place at target
  ch.steps[targetTick].on = true;
  ch.steps[targetTick].wave = wave;
  ch.steps[targetTick].dur = dur;

  gridDragData = null;
  selectStep(targetCh, targetTick);
}

// RT Grid D&D
var rtGridDragData = null;
function rtGridDragStart(e, tickPos, laneType) {
  var ch = rtState[0];
  var step = ch.steps[tickPos];
  if (!step || !step.on) { e.preventDefault(); return; }
  rtGridDragData = { tick: tickPos, lane: laneType, wave: step.wave, dur: step.dur };
  e.currentTarget.classList.add('drag-source');
  e.dataTransfer.effectAllowed = 'move';
  e.dataTransfer.setData('text/plain', 'rt-grid-drag');
}

function rtGridDrop(e, targetTick, targetLane) {
  e.preventDefault();
  e.currentTarget.classList.remove('drag-over');
  if (!rtGridDragData) return;

  var ch = rtState[0];
  var srcTick = rtGridDragData.tick;
  var wave = rtGridDragData.wave;
  var dur = rtGridDragData.dur;

  var isNorm = (targetLane === 'normal');
  if (isNorm && !isNormalDur(dur)) { rtGridDragData = null; return; }
  if (!isNorm && !isTripletDur(dur)) { rtGridDragData = null; return; }

  var span = durToSteps(dur);
  if (targetTick + span > ch.count) { rtGridDragData = null; return; }

  ch.steps[srcTick].on = false;
  ch.steps[srcTick].wave = 'triangle';
  ch.steps[srcTick].dur = 16;

  for (var j = 0; j < span && targetTick + j < ch.count; j++) ch.steps[targetTick + j].on = false;

  ch.steps[targetTick].on = true;
  ch.steps[targetTick].wave = wave;
  ch.steps[targetTick].dur = dur;

  rtGridDragData = null;
  selectRTStep(targetTick);
}

// ============================================================
//  FILL GAP (fill empty spaces between events with Low/silent)
// ============================================================
function fillGaps(c) {
  var ch = state[c];
  var events = getEventChain(c);
  if (events.length === 0) return;

  // Find gaps between events and after last event up to ch.count
  var avail = getAvailableDurs();
  var gaps = [];

  for (var ei = 0; ei < events.length; ei++) {
    var evEnd = events[ei].step + durToSteps(events[ei].dur);
    var nextStart = (ei + 1 < events.length) ? events[ei + 1].step : ch.count;
    if (evEnd < nextStart) {
      gaps.push({ start: evEnd, len: nextStart - evEnd });
    }
  }
  // Gap before first event
  if (events[0].step > 0) {
    gaps.unshift({ start: 0, len: events[0].step });
  }

  // Fill each gap with Low notes
  gaps.forEach(function(gap) {
    var pos = gap.start;
    var remaining = gap.len;
    while (remaining > 0) {
      // Find largest fitting duration
      var filled = false;
      for (var a = avail.length - 1; a >= 0; a--) {
        var span = durToSteps(avail[a]);
        // Check grid alignment
        var onNorm = (pos % 3 === 0) && isNormalDur(avail[a]);
        var onTrip = (pos % 2 === 0) && isTripletDur(avail[a]);
        if ((onNorm || onTrip) && span <= remaining) {
          ch.steps[pos].on = true;
          ch.steps[pos].wave = 'low';
          ch.steps[pos].dur = avail[a];
          pos += span;
          remaining -= span;
          filled = true;
          break;
        }
      }
      if (!filled) {
        pos++;
        remaining--;
      }
    }
  });

  buildUI();
}

function clearChannel(c) {
  var ch = state[c];
  for (var i = 0; i < ch.steps.length; i++) ch.steps[i].on = false;
  deselectStep(c);
  rangeSelection = { channel: -1, steps: [] };
  buildUI();
  document.getElementById('status').textContent = CNAME[c] + ' cleared';
}

function clearRTChannel() {
  var ch = rtState[0];
  for (var i = 0; i < ch.steps.length; i++) ch.steps[i].on = false;
  deselectRTStep();
  rtRangeSelection = { steps: [] };
  renderRTGrid(); renderRTEventChain();
  document.getElementById('status').textContent = 'RT cleared';
}

// ============================================================
//  POOL PATTERN DELETE (unused patterns only)
// ============================================================
function deletePoolPattern(type, idx) {
  if (type === 'back') {
    // Safety: cannot delete if used in song
    for (var i = 0; i < song.length; i++) {
      if (song[i].patIdx === idx) return;
    }
    if (patterns.length <= 1) return;

    var delName = patterns[idx].name;
    patterns.splice(idx, 1);

    // Remap song patIdx references
    for (var i = 0; i < song.length; i++) {
      if (song[i].patIdx > idx) song[i].patIdx--;
    }

    // Fix currentPatternIdx
    if (currentPatternIdx === idx) {
      currentPatternIdx = Math.min(idx, patterns.length - 1);
    } else if (currentPatternIdx > idx) {
      currentPatternIdx--;
    }
    state = patterns[currentPatternIdx].channels;

    // Fix selection
    selectedPoolIdx = -1;
    if (selectedSongCell >= song.length) selectedSongCell = song.length - 1;

    buildUI(); renderSongLane(); renderPatternSelect(); renderPatternPool();
    document.getElementById('status').textContent = 'Pattern "' + delName + '" deleted from pool';

  } else {
    // RT
    for (var i = 0; i < rtSong.length; i++) {
      if (rtSong[i].patIdx === idx) return;
    }
    if (rtPatterns.length <= 1) return;

    var delName = rtPatterns[idx].name;
    rtPatterns.splice(idx, 1);

    for (var i = 0; i < rtSong.length; i++) {
      if (rtSong[i].patIdx > idx) rtSong[i].patIdx--;
    }

    if (currentRTPatternIdx === idx) {
      currentRTPatternIdx = Math.min(idx, rtPatterns.length - 1);
    } else if (currentRTPatternIdx > idx) {
      currentRTPatternIdx--;
    }
    rtState = rtPatterns[currentRTPatternIdx].channels;

    selectedRTPoolIdx = -1;
    if (selectedRTSongCell >= rtSong.length) selectedRTSongCell = rtSong.length - 1;

    buildRTUI(); renderRTSongLane(); renderRTPatternSelect(); renderPatternPool();
    document.getElementById('status').textContent = 'RT Pattern "' + delName + '" deleted from pool';
  }
}

// Legacy alias
function gridCellClick(c, s) { laneCellClick(c, s, isNormalDur(state[c].steps[s] && state[c].steps[s].dur ? state[c].steps[s].dur : 16) ? 'normal' : 'triplet'); }

// ============================================================
//  STEP COUNT CONTROLS
// ============================================================
function adjCount(c, d) {
  var max = getMax();
  var newVal = Math.max(1, Math.min(max, state[c].count + d));
  // Apply to all channels and sync PAT LEN
  for (var i = 0; i < 3; i++) {
    state[i].count = newVal;
    var scEl = document.getElementById('sc' + i);
    if (scEl) scEl.value = newVal;
  }
  patterns[currentPatternIdx].patternLength = newVal;
  var lenEl = document.getElementById('patLen');
  if (lenEl) lenEl.value = newVal;
  buildUI();
}

function setCount(c, val) {
  var max = getMax();
  var newVal = Math.max(1, Math.min(max, parseInt(val) || 1));
  // Apply to all channels and sync PAT LEN
  for (var i = 0; i < 3; i++) {
    state[i].count = newVal;
    var scEl = document.getElementById('sc' + i);
    if (scEl) scEl.value = newVal;
  }
  patterns[currentPatternIdx].patternLength = newVal;
  var lenEl = document.getElementById('patLen');
  if (lenEl) lenEl.value = newVal;
  buildUI();
}

// ============================================================
//  STEP SELECTION & SYNC
// ============================================================
function selectStep(c, s) {
  // Deselect other channels
  for (var i = 0; i < 3; i++) {
    if (i !== c && state[i].selectedStep >= 0) {
      state[i].selectedStep = -1;
      updateSelectionLabel(i);
      drawWaveformPreview(i);
    }
  }
  var ch = state[c];
  ch.selectedStep = s;
  var step = ch.steps[s];
  // Sync CH block wave/dur selectors
  var wSelEl = document.getElementById('wsel' + c);
  var dSelEl = document.getElementById('dsel' + c);
  if (wSelEl) wSelEl.value = step.wave;
  if (dSelEl) {
    var hasOption = false;
    for (var i = 0; i < dSelEl.options.length; i++) {
      if (parseInt(dSelEl.options[i].value) === step.dur) { hasOption = true; break; }
    }
    if (hasOption) dSelEl.value = step.dur;
  }
  updateSelectionLabel(c);
  drawWaveformPreview(c);
  renderSplitGrid();
  for (var i = 0; i < 3; i++) renderEventChain(i);
  // Sync grid-inline selectors AFTER renderSplitGrid (which recreates them)
  var gwSelEl = document.getElementById('gwsel' + c);
  var gdSelEl = document.getElementById('gdsel' + c);
  if (gwSelEl) gwSelEl.value = step.wave;
  if (gdSelEl) gdSelEl.value = step.dur;
}

function deselectStep(c) {
  var ch = state[c];
  ch.selectedStep = -1;
  var wEl = document.getElementById('wsel' + c); if (wEl) wEl.value = ch.brushWave;
  var dEl = document.getElementById('dsel' + c); if (dEl) dEl.value = ch.brushDur;
  var gwEl = document.getElementById('gwsel' + c); if (gwEl) gwEl.value = ch.brushWave;
  var gdEl = document.getElementById('gdsel' + c); if (gdEl) gdEl.value = ch.brushDur;
  updateSelectionLabel(c);
  drawWaveformPreview(c);
}

function updateSelectionLabel(c) {
  var ch = state[c];
  var label = document.getElementById('slabel' + c);
  if (!label) return;
  if (ch.selectedStep >= 0) {
    label.textContent = 'STEP ' + (ch.selectedStep + 1);
    label.className = 'sel-label active';
  } else {
    label.textContent = 'DEFAULT';
    label.className = 'sel-label';
  }
}

function onWaveSelect(c, id) {
  var ch = state[c];
  if (ch.selectedStep >= 0 && ch.steps[ch.selectedStep] && ch.steps[ch.selectedStep].on) {
    ch.steps[ch.selectedStep].wave = id;
  } else {
    ch.brushWave = id;
  }
  updateWaveUI(c);
  renderSplitGrid();
  renderEventChain(c);
}

function onDurSelect(c, dur) {
  var ch = state[c];
  if (ch.selectedStep >= 0 && ch.steps[ch.selectedStep] && ch.steps[ch.selectedStep].on) {
    var s = ch.selectedStep;
    // Check grid compatibility: normal durs need pos%3===0, triplet need pos%2===0
    var compatible = (isNormalDur(dur) && s % 3 === 0) || (isTripletDur(dur) && s % 2 === 0);
    if (!compatible) {
      document.getElementById('dsel' + c).value = ch.steps[s].dur;
      return;
    }
    // Find event index before repack
    var evBefore = getEventChain(c);
    var evIdx = -1;
    for (var ei = 0; ei < evBefore.length; ei++) {
      if (evBefore[ei].step === s) { evIdx = ei; break; }
    }
    ch.steps[s].dur = dur;
    // Repack to auto-shift following events
    repackEvents(c);
    // Re-select same event by chain index
    var evAfter = getEventChain(c);
    if (evIdx >= 0 && evIdx < evAfter.length) {
      selectStep(c, evAfter[evIdx].step);
    } else {
      renderSplitGrid();
      renderEventChain(c);
    }
  } else {
    ch.brushDur = dur;
  }
}

function setFreq(c, val) {
  var v = Math.max(50, Math.min(2000, parseInt(val) || 50));
  if (globalAudioMode[c]) { globalAudio[c].freq = v; } else { state[c].freq = v; }
  var fInput = document.getElementById('freqv' + c);
  if (fInput) fInput.value = v;
}

function setFreqInput(c, val) {
  var v = Math.max(50, Math.min(2000, parseInt(val) || 50));
  if (globalAudioMode[c]) { globalAudio[c].freq = v; } else { state[c].freq = v; }
  var fSlider = document.getElementById('freq' + c);
  if (fSlider) fSlider.value = v;
  var fInput = document.getElementById('freqv' + c);
  if (fInput) fInput.value = v;
}

function setVolume(c, val) {
  var v = parseInt(val) / 100;
  if (globalAudioMode[c]) { globalAudio[c].volume = v; } else { state[c].volume = v; }
  var vLabel = document.getElementById('volv' + c);
  if (vLabel) vLabel.textContent = val;
}

function setPan(c, val) {
  var v = Math.max(-100, Math.min(100, parseInt(val) || 0));
  if (globalAudioMode[c]) { globalAudio[c].pan = v; } else { state[c].pan = v; }
  var pLabel = document.getElementById('panv' + c);
  if (pLabel) pLabel.textContent = v === 0 ? 'C' : (v < 0 ? 'L' + Math.abs(v) : 'R' + v);
}

function toggleSmooth(c) {
  if (SMOOTH_NO_EFFECT.indexOf(state[c].brushWave) >= 0) return;
  state[c].smooth = !state[c].smooth;
  updateWaveUI(c);
}

function toggleBipolar(c) {
  state[c].bipolar = !state[c].bipolar;
  updateWaveUI(c);
}

function updateWaveUI(c) {
  var ch = state[c];
  var smoothDisabled = SMOOTH_NO_EFFECT.indexOf(ch.brushWave) >= 0;
  var smoothBtn = document.getElementById('wsmooth' + c);
  var bipolarBtn = document.getElementById('wbipolar' + c);
  if (smoothBtn) smoothBtn.className = 'wave-mod' + (smoothDisabled ? ' disabled' : (ch.smooth ? ' active-smooth' : ''));
  if (bipolarBtn) bipolarBtn.className = 'wave-mod' + (ch.bipolar ? ' active-bipolar' : '');
  drawWaveformPreview(c);
}

// ============================================================
//  AUDIO ENGINE
// ============================================================
function initAudio() {
  if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  if (audioCtx.state === 'suspended') audioCtx.resume();
}

function stopChannelAudio(c) {
  if (activeAudio[c]) { try { activeAudio[c].stop(); } catch(e){} activeAudio[c] = null; }
}
function stopAllAudio() { for (var c = 0; c < 4; c++) stopChannelAudio(c); }

function playLFONote(c, duration, waveType, optChannels) {
  var ch = (optChannels || state)[c];
  var audio = getChAudio(c, optChannels);
  if (waveType === 'low' && !ch.bipolar) return;
  stopChannelAudio(c);
  duration = Math.min(duration, 4.0);
  if (duration < 0.005) return;

  var sr = audioCtx.sampleRate;
  var len = Math.ceil(sr * duration);
  if (len === 0) return;
  var buf = audioCtx.createBuffer(1, len, sr);
  var data = buf.getChannelData(0);
  var freq = audio.freq;
  var vol = audio.volume;
  var fadeLen = Math.max(Math.ceil(sr * 0.003), Math.ceil(len * 0.03));
  for (var i = 0; i < len; i++) {
    var lfoT = i / len;
    var lfo = getLFOValue(waveType, ch.smooth, lfoT);
    if (ch.bipolar) lfo = lfo * 2 - 1;
    var carrier = Math.sin(2 * Math.PI * freq * i / sr);
    var fade = 1;
    if (i > len - fadeLen) fade = (len - i) / fadeLen;
    data[i] = carrier * lfo * vol * fade;
  }
  var src = audioCtx.createBufferSource();
  src.buffer = buf;
  if (audioCtx.createStereoPanner && audio.pan !== 0) {
    var panner = audioCtx.createStereoPanner();
    panner.pan.value = audio.pan / 100;
    src.connect(panner);
    panner.connect(audioCtx.destination);
  } else {
    src.connect(audioCtx.destination);
  }
  src.start();
  activeAudio[c] = src;
}

// Play RT note (uses channel index 3 in activeAudio)
function playRTNote(duration, waveType, optChannels) {
  var ch = (optChannels || rtState)[0];
  var audio = getRTAudio(optChannels);
  if (waveType === 'low' && !ch.bipolar) return;
  stopChannelAudio(3);
  duration = Math.min(duration, 4.0);
  if (duration < 0.005) return;

  var sr = audioCtx.sampleRate;
  var len = Math.ceil(sr * duration);
  if (len === 0) return;
  var buf = audioCtx.createBuffer(1, len, sr);
  var data = buf.getChannelData(0);
  var freq = audio.freq;
  var vol = audio.volume;
  var fadeLen = Math.max(Math.ceil(sr * 0.003), Math.ceil(len * 0.03));
  for (var i = 0; i < len; i++) {
    var lfoT = i / len;
    var lfo = getLFOValue(waveType, ch.smooth, lfoT);
    if (ch.bipolar) lfo = lfo * 2 - 1;
    var carrier = Math.sin(2 * Math.PI * freq * i / sr);
    var fade = 1;
    if (i > len - fadeLen) fade = (len - i) / fadeLen;
    data[i] = carrier * lfo * vol * fade;
  }
  var src = audioCtx.createBufferSource();
  src.buffer = buf;
  if (audioCtx.createStereoPanner && audio.pan !== 0) {
    var panner = audioCtx.createStereoPanner();
    panner.pan.value = audio.pan / 100;
    src.connect(panner);
    panner.connect(audioCtx.destination);
  } else {
    src.connect(audioCtx.destination);
  }
  src.start();
  activeAudio[3] = src;
}

// ============================================================
//  PLAYBACK
// ============================================================
function clearPlayingHighlights() {
  document.querySelectorAll('.n-cell.playing, .t-cell.playing').forEach(function(e) { e.classList.remove('playing'); });
}

function highlightLaneCells(c, tickPos) {
  // Highlight normal lane cell if tick aligns
  if (tickPos % 3 === 0) {
    var nCell = document.getElementById('nc_' + c + '_' + (tickPos / 3));
    if (nCell) nCell.classList.add('playing');
  }
  // Highlight triplet lane cell if tick aligns
  if (tickPos % 2 === 0) {
    var tCell = document.getElementById('tc_' + c + '_' + (tickPos / 2));
    if (tCell) tCell.classList.add('playing');
  }
}

// Playhead bar management
function clearPlayheadBars() {
  document.querySelectorAll('.playhead-bar').forEach(function(el) { el.remove(); });
}

function updatePlayheadBars(tickPos) {
  clearPlayheadBars();
  // Show playhead on both normal and triplet lanes for all channels
  for (var c = 0; c < 3; c++) {
    var nCellIdx = Math.floor(tickPos / 3);
    var nCellEl = document.getElementById('nc_' + c + '_' + nCellIdx);
    if (nCellEl && nCellEl.parentElement) {
      var row = nCellEl.parentElement;
      var bar = document.createElement('div');
      bar.className = 'playhead-bar';
      var fraction = (tickPos % 3) / 3;
      bar.style.left = (nCellEl.offsetLeft + fraction * nCellEl.offsetWidth) + 'px';
      row.appendChild(bar);
    }
    var tCellIdx = Math.floor(tickPos / 2);
    var tCellEl = document.getElementById('tc_' + c + '_' + tCellIdx);
    if (tCellEl && tCellEl.parentElement) {
      var row = tCellEl.parentElement;
      var bar = document.createElement('div');
      bar.className = 'playhead-bar';
      var fraction = (tickPos % 2) / 2;
      bar.style.left = (tCellEl.offsetLeft + fraction * tCellEl.offsetWidth) + 'px';
      row.appendChild(bar);
    }
  }
  // RT lanes playhead
  var rnCellIdx = Math.floor(tickPos / 3);
  var rnCellEl = document.getElementById('rnc_0_' + rnCellIdx);
  if (rnCellEl && rnCellEl.parentElement) {
    var row = rnCellEl.parentElement;
    var bar = document.createElement('div');
    bar.className = 'playhead-bar';
    bar.style.left = (rnCellEl.offsetLeft + ((tickPos % 3) / 3) * rnCellEl.offsetWidth) + 'px';
    row.appendChild(bar);
  }
  var rtCellIdx = Math.floor(tickPos / 2);
  var rtCellEl = document.getElementById('rtc_0_' + rtCellIdx);
  if (rtCellEl && rtCellEl.parentElement) {
    var row = rtCellEl.parentElement;
    var bar = document.createElement('div');
    bar.className = 'playhead-bar';
    bar.style.left = (rtCellEl.offsetLeft + ((tickPos % 2) / 2) * rtCellEl.offsetWidth) + 'px';
    row.appendChild(bar);
  }
}

function highlightRTLaneCells(tickPos) {
  if (tickPos % 3 === 0) {
    var el = document.getElementById('rnc_0_' + (tickPos / 3));
    if (el) el.classList.add('playing');
  }
  if (tickPos % 2 === 0) {
    var el = document.getElementById('rtc_0_' + (tickPos / 2));
    if (el) el.classList.add('playing');
  }
}

function tick() {
  // Clear previous playing
  clearPlayingHighlights();

  var playTickPos = curStep % (patterns[currentPatternIdx].patternLength || 128);

  for (var c = 0; c < 3; c++) {
    var ch = state[c];
    var s = curStep % ch.count;
    var step = ch.steps[s];
    if (step && step.on && !chMute[c]) {
      var durSec = durToSteps(step.dur) * stepIntervalMs() / 1000;
      playLFONote(c, durSec, step.wave);
    }
    highlightLaneCells(c, s);
  }

  // RT channel playback
  var rtCh = rtState[0];
  var rtS = curStep % rtCh.count;
  var rtStep = rtCh.steps[rtS];
  if (rtStep && rtStep.on && !chMute[3]) {
    var rtDurSec = durToSteps(rtStep.dur) * stepIntervalMs() / 1000;
    playRTNote(rtDurSec, rtStep.wave);
  }
  // Highlight RT lane cells
  highlightRTLaneCells(rtS);

  // Update playhead bar position
  updatePlayheadBars(playTickPos);

  document.getElementById('status').textContent = '\u25B6 STEP ' + (curStep + 1);
  curStep++;

  // Check pattern length for loop/stop
  var patLen = patterns[currentPatternIdx].patternLength || 128;
  if (curStep >= patLen) {
    if (songLoop) {
      curStep = 0;
    } else {
      doStop(true);
      return;
    }
  }
  timer = setTimeout(tick, stepIntervalMs());
}

// Pattern play (single pattern loop)
function doPlay() {
  initAudio();
  if (!isPlaying) {
    songPlaying = false;
    isPlaying = true;
    curStep = 0;
    document.getElementById('btnPlay').textContent = '\u23F8 PAUSE';
    document.getElementById('btnPlay').classList.add('playing');
    tick();
  } else {
    doStop(false);
  }
}

// Song play
function doSongPlay() {
  initAudio();
  if (!songPlaying) {
    doStop(true);
    songPlaying = true;
    isPlaying = true;
    songPos = Math.min(songPlayhead, song.length - 1);
    songRepeatCount = 0;
    curStep = 0;
    // RT starts from same position
    rtSongPos = Math.min(songPlayhead, rtSong.length - 1);
    rtSongRepeatCount = 0;
    
    // Switch to starting patterns
    var startPat = song[songPos] ? song[songPos].patIdx : 0;
    switchToPattern(startPat);
    if (rtSong[rtSongPos]) switchToRTPattern(rtSong[rtSongPos].patIdx);
    document.getElementById('btnSongPlay').textContent = '\u23F8 PAUSE';
    document.getElementById('btnSongPlay').classList.add('playing');
    songTick();
  } else {
    doStop(true);
  }
}

// RT song position tracking
var rtSongPos = 0, rtSongRepeatCount = 0;

function songTick() {
  if (!songPlaying || songPos >= song.length) {
    doStop(true);
    return;
  }
  var entry = song[songPos];
  var pat = patterns[entry.patIdx];
  if (!pat) { doStop(true); return; }

  // Clear previous playing
  clearPlayingHighlights();

  var channels = pat.channels;
  var patLen = pat.patternLength || 128;
  var stepInPattern = curStep % patLen;

  for (var c = 0; c < 3; c++) {
    var ch = channels[c];
    var s = curStep % ch.count;
    var step = ch.steps[s];
    if (step && step.on && !chMute[c]) {
      var durSec = durToSteps(step.dur) * stepIntervalMs() / 1000;
      playLFONote(c, durSec, step.wave, channels);
    }
    if (currentPatternIdx === entry.patIdx) {
      highlightLaneCells(c, s);
    }
  }

  // RT channel playback (parallel song)
  if (rtSongPos < rtSong.length) {
    var rtEntry = rtSong[rtSongPos];
    var rtPat = rtPatterns[rtEntry.patIdx];
    if (rtPat) {
      var rtChannel = rtPat.channels[0];
      var rtPatLen = rtPat.patternLength || 128;
      var rtS = curStep % rtChannel.count;
      var rtStep = rtChannel.steps[rtS];
      if (rtStep && rtStep.on && !chMute[3]) {
        var rtDurSec = durToSteps(rtStep.dur) * stepIntervalMs() / 1000;
        playRTNote(rtDurSec, rtStep.wave, rtPat.channels);
      }
      if (currentRTPatternIdx === rtEntry.patIdx) {
        highlightRTLaneCells(rtS);
      }
    }
  }

  // Update playhead bar position (only for displayed pattern)
  if (currentPatternIdx === entry.patIdx) {
    updatePlayheadBars(stepInPattern);
  }

  // Highlight song cells
  document.querySelectorAll('.song-cell.song-playing').forEach(function(e) { e.classList.remove('song-playing'); });
  var songCells = document.getElementById('songLane');
  if (songCells) { var cells = songCells.querySelectorAll('.song-cell'); if (cells[songPos]) cells[songPos].classList.add('song-playing'); }
  var rtSongLane = document.getElementById('rtSongLane');
  if (rtSongLane && rtSongPos < rtSong.length) { var rtCells = rtSongLane.querySelectorAll('.song-cell'); if (rtCells[rtSongPos]) rtCells[rtSongPos].classList.add('song-playing'); }

  var statusText = '\u25B6 SONG [' + pat.name + '] rep ' + (songRepeatCount + 1) + '/' + entry.repeat + ' step ' + (stepInPattern + 1);
  document.getElementById('status').textContent = statusText;

  curStep++;

  // Check if back pattern completed one cycle
  if (curStep >= patLen) {
    curStep = 0;
    songRepeatCount++;
    if (songRepeatCount >= entry.repeat) {
      songRepeatCount = 0;
      songPos++;
      if (songPos >= song.length) {
        if (songLoop) { songPos = 0; } else { doStop(true); return; }
      }
      var nextEntry = song[songPos];
      if (nextEntry && patterns[nextEntry.patIdx]) switchToPattern(nextEntry.patIdx);
    }
  }

  // Check if RT pattern completed one cycle
  if (rtSongPos < rtSong.length) {
    var rtEntry2 = rtSong[rtSongPos];
    var rtPat2 = rtPatterns[rtEntry2.patIdx];
    var rtPatLen2 = rtPat2 ? (rtPat2.patternLength || 128) : 128;
    if (curStep + 1 >= patLen) {
      
      rtSongRepeatCount++;
      if (rtSongRepeatCount >= rtEntry2.repeat) {
        rtSongRepeatCount = 0;
        rtSongPos++;
        if (rtSongPos >= rtSong.length) {
          if (songLoop) { rtSongPos = 0; }
          // else RT just stops (back song controls overall stop)
        }
        if (rtSongPos < rtSong.length) switchToRTPattern(rtSong[rtSongPos].patIdx);
      }
    }
  }

  timer = setTimeout(songTick, stepIntervalMs());
}

function doStop(reset) {
  isPlaying = false;
  songPlaying = false;
  clearTimeout(timer);
  stopAllAudio();
  clearPlayingHighlights();
  clearPlayheadBars();
  document.querySelectorAll('.song-cell.song-playing').forEach(function(e) { e.classList.remove('song-playing'); });
  document.getElementById('btnPlay').textContent = '\u25B6 PAT PLAY';
  document.getElementById('btnPlay').classList.remove('playing');
  document.getElementById('btnSongPlay').textContent = '\u25B6 SONG PLAY';
  document.getElementById('btnSongPlay').classList.remove('playing');
  if (reset) { curStep = 0; songPos = 0; songRepeatCount = 0;  rtSongPos = 0; rtSongRepeatCount = 0; }
  document.getElementById('status').textContent = 'クリックで入力 | 上段で波形/DUR変更';
}

document.getElementById('btnPlay').onclick = doPlay;
document.getElementById('btnSongPlay').onclick = doSongPlay;
document.getElementById('btnLoop').onclick = function() {
  songLoop = !songLoop;
  this.textContent = 'LOOP: ' + (songLoop ? 'ON' : 'OFF');
  this.className = 'main' + (songLoop ? ' active' : '');
  this.id = 'btnLoop';
};
document.getElementById('btnStop').onclick = function() { doStop(true); };

document.getElementById('btnClear').onclick = function() {
  state.forEach(function(ch, c) {
    ch.steps.forEach(function(step) { step.on = false; });
    deselectStep(c);
  });
  renderSplitGrid();
  for (var c = 0; c < 3; c++) renderEventChain(c);
};

document.getElementById('btnSongClear').onclick = function() {
  if (!confirm('Reset song to single pattern A?')) return;
  doStop(false);
  var firstPat = makePattern('A');
  patterns = [firstPat];
  song = [{ patIdx: 0, repeat: 1 }];
  currentPatternIdx = 0;
  state = patterns[0].channels;
  selectedSongCell = 0;
  cellClipboard = null;
  patternClipboard = null;
  // Reset RT too
  rtPatterns = [makeRTPattern('RA')];
  rtSong = [{ patIdx: 0, repeat: 1 }];
  currentRTPatternIdx = 0;
  rtState = rtPatterns[0].channels;
  selectedRTSongCell = 0;
  buildUI();
  buildRTUI();
  renderRTSongLane();
  renderPatternPool();
  document.getElementById('status').textContent = 'Song cleared';
};

document.getElementById('btnAutoLen').onclick = autoPatternLength;

// ============================================================
//  MIDI EXPORT
// ============================================================
function varLen(n) {
  var b = [n & 0x7f]; n >>= 7;
  while (n > 0) { b.unshift((n & 0x7f) | 0x80); n >>= 7; }
  return b;
}

document.getElementById('btnExport').onclick = function() {
  var bpm = getBPM(), quant = getQuant();
  var PPQ = 480;
  var tps = PPQ * 4 / quant;
  var tempo = Math.round(60000000 / bpm);

  var evts = [];
  evts.push({ tick: 0, data: [0xFF, 0x51, 0x03, (tempo >> 16) & 0xff, (tempo >> 8) & 0xff, tempo & 0xff] });

  var totalSteps = patterns[currentPatternIdx].patternLength || 128;
  var totalTicks = totalSteps * tps;

  for (var c = 0; c < 3; c++) {
    var ch = state[c];
    var note = ch.note, mch = (ch.mich - 1) & 0x0f;
    for (var s = 0; s < totalSteps; s++) {
      var step = ch.steps[s % ch.count];
      if (step && step.on) {
        var t = s * tps;
        var noteDurTicks = durToSteps(step.dur) * tps;
        evts.push({ tick: t, data: [0x90 | mch, note, 100] });
        evts.push({ tick: t + noteDurTicks - 1, data: [0x80 | mch, note, 0] });
      }
    }
  }

  // RT channel
  var rtCh = rtState[0];
  var rtNote = rtCh.note, rtMch = (rtCh.mich - 1) & 0x0f;
  for (var s = 0; s < totalSteps; s++) {
    var step = rtCh.steps[s % rtCh.count];
    if (step && step.on) {
      var t = s * tps;
      var noteDurTicks = durToSteps(step.dur) * tps;
      evts.push({ tick: t, data: [0x90 | rtMch, rtNote, 100] });
      evts.push({ tick: t + noteDurTicks - 1, data: [0x80 | rtMch, rtNote, 0] });
    }
  }

  evts.push({ tick: totalTicks, data: [0xFF, 0x2F, 0x00] });
  evts.sort(function(a, b) { return a.tick - b.tick || (a.data[0] === 0x80 ? -1 : 1); });

  var trk = []; var prev = 0;
  for (var i = 0; i < evts.length; i++) {
    var ev = evts[i];
    trk.push.apply(trk, varLen(ev.tick - prev));
    prev = ev.tick;
    trk.push.apply(trk, ev.data);
  }

  var hdr = [0x4D, 0x54, 0x68, 0x64, 0, 0, 0, 6, 0, 0, 0, 1, (PPQ >> 8) & 0xff, PPQ & 0xff];
  var tl = trk.length;
  var trkH = [0x4D, 0x54, 0x72, 0x6B, (tl >> 24) & 0xff, (tl >> 16) & 0xff, (tl >> 8) & 0xff, tl & 0xff];

  var all = hdr.concat(trkH, trk);
  var blob = new Blob([new Uint8Array(all)], { type: 'audio/midi' });
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'seq_' + bpm + 'bpm.mid';
  a.click();
  document.getElementById('status').textContent = 'MIDIファイルをダウンロードしました \u2713';
};

// ============================================================
//  PROJECT SAVE / LOAD
// ============================================================
function serializeChannels(channels) {
  return channels.map(function(ch) {
    return {
      count: ch.count, note: ch.note, mich: ch.mich,
      brushWave: ch.brushWave, brushDur: ch.brushDur,
      smooth: ch.smooth, bipolar: ch.bipolar, volume: ch.volume,
      freq: ch.freq, pan: ch.pan,
      steps: ch.steps.slice(0, ch.count).map(function(s) {
        return { on: s.on, wave: s.wave, dur: s.dur };
      })
    };
  });
}

var projectName = '';

function saveProject() {
  // Ask for project name on first save
  if (!projectName) {
    var name = prompt('Project name:', 'MyProject');
    if (!name) name = 'MyProject';
    projectName = name.trim() || 'MyProject';
  }
  var proj = {
    version: 6,
    bpm: getBPM(),
    quant: getQuant(),
    projectName: projectName,
    patterns: patterns.map(function(p) {
      return { name: p.name, channels: serializeChannels(p.channels), baseName: p.baseName || p.name.charAt(0), varySuffix: p.varySuffix || '', patternLength: p.patternLength || 128 };
    }),
    song: song.slice(),
    songLoop: songLoop,
    currentPatternIdx: currentPatternIdx,
    globalAudioMode: globalAudioMode,
    globalAudio: globalAudio,
    theme: currentTheme,
    // RT data
    rtPatterns: rtPatterns.map(function(p) {
      return { name: p.name, channels: serializeChannels(p.channels), baseName: p.baseName || p.name.charAt(0), varySuffix: p.varySuffix || '', patternLength: p.patternLength || 128, coverBackFrom: p.coverBackFrom || -1, coverBackTo: p.coverBackTo || -1 };
    }),
    rtSong: rtSong.slice(),
    currentRTPatternIdx: currentRTPatternIdx,
    rtGlobalAudio: rtGlobalAudio,
    chMute: chMute
  };
  var json = JSON.stringify(proj, null, 2);
  var blob = new Blob([json], { type: 'application/json' });
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  var now = new Date();
  var ts = now.getFullYear() +
    ('0' + (now.getMonth() + 1)).slice(-2) +
    ('0' + now.getDate()).slice(-2) + '_' +
    ('0' + now.getHours()).slice(-2) +
    ('0' + now.getMinutes()).slice(-2) +
    ('0' + now.getSeconds()).slice(-2);
  a.download = projectName + '_' + ts + '.json';
  a.click();
  document.getElementById('status').textContent = projectName + ' saved \u2713 (' + ts + ')';
}

function loadChannels(srcChannels, destChannels) {
  var avail = getAvailableDurs();
  var max = getMax();
  for (var c = 0; c < 3; c++) {
    var src = srcChannels[c];
    if (!src) continue;
    var ch = destChannels[c];
    ch.count = src.count || 16;
    ch.note = src.note !== undefined ? src.note : ch.note;
    ch.mich = src.mich !== undefined ? src.mich : ch.mich;
    ch.brushWave = src.brushWave || 'ramp_up';
    ch.brushDur = src.brushDur || avail[0];
    ch.smooth = !!src.smooth;
    ch.bipolar = !!src.bipolar;
    ch.volume = src.volume !== undefined ? src.volume : 0.5;
    ch.freq = src.freq !== undefined ? src.freq : CARRIER_FREQS[c];
    ch.pan = src.pan !== undefined ? src.pan : 0;
    ch.selectedStep = -1;
    ch.steps = [];
    for (var i = 0; i < max; i++) {
      if (src.steps && src.steps[i]) {
        var ss = src.steps[i];
        ch.steps.push({ on: !!ss.on, wave: WAVE_SYM[ss.wave] ? ss.wave : 'ramp_up', dur: avail.indexOf(ss.dur) >= 0 ? ss.dur : avail[0] });
      } else {
        ch.steps.push(makeStep());
      }
    }
    if (avail.indexOf(ch.brushDur) < 0) ch.brushDur = avail[0];
  }
}

// Migrate quant-16 step data → quant-96 positions
function migrateQuant16To96(channels) {
  channels.forEach(function(ch) {
    var oldSteps = ch.steps.slice(0, 16);
    ch.steps = [];
    for (var i = 0; i < 96; i++) ch.steps.push(makeStep());
    for (var i = 0; i < oldSteps.length; i++) {
      if (oldSteps[i] && oldSteps[i].on) {
        var newPos = i * 6; // 96/16 = 6
        if (newPos < 96) {
          ch.steps[newPos] = { on: true, wave: oldSteps[i].wave, dur: oldSteps[i].dur };
        }
      }
    }
    // Scale count proportionally
    ch.count = Math.min(96, Math.max(6, (ch.count || 16) * 6));
  });
}

function loadProject(json) {
  try {
    var proj = JSON.parse(json);
    if (proj.projectName) projectName = proj.projectName;
    document.getElementById('bpm').value = proj.bpm || 120;
    var savedQuant = proj.quant || 16;  // remember for migration

    if (proj.version >= 3 && proj.patterns) {
      // Version 3: multi-pattern + song
      patterns = [];
      proj.patterns.forEach(function(p) {
        var pat = makePattern(p.name || 'A');
        pat.baseName = p.baseName || p.name.charAt(0) || 'A';
        pat.varySuffix = p.varySuffix || '';
        pat.patternLength = p.patternLength || 128;
        loadChannels(p.channels, pat.channels);
        patterns.push(pat);
      });
      song = proj.song && proj.song.length > 0 ? proj.song : [{ patIdx: 0, repeat: 1 }];
      songLoop = !!proj.songLoop;
      currentPatternIdx = proj.currentPatternIdx || 0;
      if (currentPatternIdx >= patterns.length) currentPatternIdx = 0;
      state = patterns[currentPatternIdx].channels;
      selectedSongCell = 0;
      document.getElementById('btnLoop').textContent = 'LOOP: ' + (songLoop ? 'ON' : 'OFF');
      document.getElementById('btnLoop').className = 'main' + (songLoop ? ' active' : '');
      document.getElementById('btnLoop').id = 'btnLoop';
    } else {
      // Version 2 (legacy): single pattern
      patterns = [makePattern('A')];
      if (proj.channels && proj.channels.length === 3) {
        loadChannels(proj.channels, patterns[0].channels);
      } else {
        throw new Error('Invalid project');
      }
      song = [{ patIdx: 0, repeat: 1 }];
      songLoop = false;
      currentPatternIdx = 0;
      state = patterns[0].channels;
      selectedSongCell = 0;
    }

    // Migrate quant-16 projects to quant-96
    if (savedQuant === 16) {
      patterns.forEach(function(pat) {
        migrateQuant16To96(pat.channels);
      });
      state = patterns[currentPatternIdx].channels;
    }

    // V4: global audio + theme
    if (proj.globalAudio) {
      globalAudio = proj.globalAudio;
      globalAudioMode = Array.isArray(proj.globalAudioMode) ? proj.globalAudioMode : [true, true, true, true];
    } else {
      // Migrate from v3: use first pattern's channel values as global
      globalAudioMode = [true, true, true, true];
      for (var c = 0; c < 3; c++) {
        var src = patterns[0].channels[c];
        globalAudio[c] = { freq: src.freq || CARRIER_FREQS[c], volume: src.volume || 0.5, pan: src.pan || 0 };
      }
    }
    if (proj.theme && COLOR_THEMES[proj.theme]) {
      applyTheme(proj.theme);
    }

    // V6: RT data
    if (proj.rtPatterns && proj.rtPatterns.length > 0) {
      rtPatterns = [];
      proj.rtPatterns.forEach(function(p) {
        var pat = makeRTPattern(p.name || 'RA');
        pat.baseName = p.baseName || p.name || 'RA';
        pat.varySuffix = p.varySuffix || '';
        pat.patternLength = p.patternLength || 128;
        pat.coverBackFrom = p.coverBackFrom || -1;
        pat.coverBackTo = p.coverBackTo || -1;
        // Load RT channel (index 0 only)
        if (p.channels && p.channels[0]) {
          var avail = getAvailableDurs();
          var max = getMax();
          var src = p.channels[0];
          var ch = pat.channels[0];
          ch.count = src.count || 128;
          ch.note = src.note !== undefined ? src.note : 60;
          ch.mich = src.mich !== undefined ? src.mich : 4;
          ch.brushWave = src.brushWave || 'triangle';
          ch.brushDur = src.brushDur || avail[0];
          ch.smooth = !!src.smooth;
          ch.bipolar = !!src.bipolar;
          ch.volume = src.volume !== undefined ? src.volume : 0.5;
          ch.freq = src.freq !== undefined ? src.freq : RT_CARRIER_FREQ;
          ch.pan = src.pan !== undefined ? src.pan : 0;
          ch.selectedStep = -1;
          ch.steps = [];
          for (var i = 0; i < max; i++) {
            if (src.steps && src.steps[i]) {
              var ss = src.steps[i];
              ch.steps.push({ on: !!ss.on, wave: WAVE_SYM[ss.wave] ? ss.wave : 'ramp_up', dur: avail.indexOf(ss.dur) >= 0 ? ss.dur : avail[0] });
            } else {
              ch.steps.push(makeStep());
            }
          }
        }
        rtPatterns.push(pat);
      });
      rtSong = proj.rtSong && proj.rtSong.length > 0 ? proj.rtSong : [{ patIdx: 0, repeat: 1 }];
      currentRTPatternIdx = proj.currentRTPatternIdx || 0;
      if (currentRTPatternIdx >= rtPatterns.length) currentRTPatternIdx = 0;
      rtState = rtPatterns[currentRTPatternIdx].channels;
      selectedRTSongCell = 0;
      if (proj.rtGlobalAudio) rtGlobalAudio = proj.rtGlobalAudio;
    } else {
      // No RT data (loading older project): create default RT
      rtPatterns = [makeRTPattern('RA')];
      rtSong = [{ patIdx: 0, repeat: 1 }];
      currentRTPatternIdx = 0;
      rtState = rtPatterns[0].channels;
      selectedRTSongCell = 0;
      rtGlobalAudio = { freq: RT_CARRIER_FREQ, volume: 0.50, pan: 0 };
    }

    // Load mute state
    chMute = Array.isArray(proj.chMute) ? proj.chMute : [false, false, false, false];

    buildUI();
    buildRTUI();
    renderRTSongLane();
    // Sync PAT LEN input
    var lenEl = document.getElementById('patLen');
    if (lenEl) lenEl.value = patterns[currentPatternIdx].patternLength || 128;
    document.getElementById('status').textContent = 'プロジェクトを読み込みました \u2713';
  } catch (e) {
    document.getElementById('status').textContent = '読み込みエラー: ' + e.message;
  }
}

document.getElementById('btnSave').onclick = saveProject;
document.getElementById('btnLoad').onclick = function() { document.getElementById('fileLoad').click(); };
document.getElementById('fileLoad').addEventListener('change', function(e) {
  var file = e.target.files[0];
  if (!file) return;
  var reader = new FileReader();
  reader.onload = function(ev) { loadProject(ev.target.result); };
  reader.readAsText(file);
  e.target.value = '';
});

// ============================================================
//  PATTERN MANAGEMENT
// ============================================================
document.getElementById('patSelect').addEventListener('change', function() {
  if (_patSelectLocked) return;
  switchToPattern(parseInt(this.value));
});

document.getElementById('patNew').onclick = function() {
  var name = nextPatternName();
  patterns.push(makePattern(name));
  switchToPattern(patterns.length - 1);
};

document.getElementById('patRename').onclick = function() {
  var p = patterns[currentPatternIdx];
  if (!p) return;
  var newName = prompt('Rename pattern "' + p.name + '" to:', p.name);
  if (newName && newName.trim().length > 0 && newName.trim() !== p.name) {
    p.name = newName.trim();
    p.baseName = newName.trim();
    p.varySuffix = '';
    renderSongLane(); renderPatternSelect(); renderPatternPool();
  }
};

// RT pattern management
document.getElementById('rtPatSelect').addEventListener('change', function() {
  switchToRTPattern(parseInt(this.value));
});

document.getElementById('rtPatNew').onclick = function() {
  var name = nextRTPatternName();
  var pat = makeRTPattern(name);
  pat.patternLength = patterns[currentPatternIdx].patternLength || 128;
  pat.channels[0].count = pat.patternLength;
  rtPatterns.push(pat);
  switchToRTPattern(rtPatterns.length - 1);
};

document.getElementById('rtPatRename').onclick = function() {
  var p = rtPatterns[currentRTPatternIdx];
  if (!p) return;
  var newName = prompt('Rename RT pattern "' + p.name + '" to:', p.name);
  if (newName && newName.trim().length > 0 && newName.trim() !== p.name) {
    p.name = newName.trim();
    p.baseName = newName.trim();
    p.varySuffix = '';
    renderRTSongLane(); renderRTPatternSelect(); renderPatternPool();
  }
};

// ============================================================
//  RANDOM PATTERN GENERATION
// ============================================================
document.getElementById('randDensity').addEventListener('input', function() {
  document.getElementById('rdVal').textContent = this.value + '%';
});

function generateRandom() {
  var q = getQuant();
  var max = getMax();
  var avail = getAvailableDurs();
  var density = parseInt(document.getElementById('randDensity').value) / 100;

  // Random length (same for all 3 channels)
  // Pick a musically useful length: multiples of 4 for q=16, multiples of 24 for q=96
  var stepUnit = (q === 96) ? 24 : 4;
  var minUnits = 1;
  var maxUnits = Math.floor(max / stepUnit);
  var units = minUnits + Math.floor(Math.random() * maxUnits);
  var count = Math.min(units * stepUnit, max);

  for (var c = 0; c < 3; c++) {
    var ch = state[c];
    ch.count = count;
    ch.selectedStep = -1;

    // Reset all steps
    for (var i = 0; i < max; i++) {
      if (!ch.steps[i]) ch.steps[i] = makeStep();
      ch.steps[i].on = false;
    }

    // Fill events on grid-aligned positions only
    var pos = 0;
    while (pos < count) {
      // Snap to next grid-aligned position (divisible by 2 or 3)
      while (pos < count && pos % 2 !== 0 && pos % 3 !== 0) pos++;
      if (pos >= count) break;

      if (Math.random() < density) {
        var wave = WAVE_IDS[Math.floor(Math.random() * WAVE_IDS.length)];
        // Pick durations matching this grid position
        var isNormPos = (pos % 3 === 0);
        var isTripPos = (pos % 2 === 0);
        var fitDurs = [];
        for (var d = 0; d < avail.length; d++) {
          var span = durToSteps(avail[d]);
          if (pos + span > count) continue;
          if (isNormPos && isNormalDur(avail[d])) fitDurs.push(avail[d]);
          else if (isTripPos && isTripletDur(avail[d])) fitDurs.push(avail[d]);
        }
        if (fitDurs.length === 0) { pos++; continue; }
        var dur = fitDurs[Math.floor(Math.random() * fitDurs.length)];
        var span = durToSteps(dur);

        ch.steps[pos].on = true;
        ch.steps[pos].wave = wave;
        ch.steps[pos].dur = dur;

        for (var j = 1; j < span && pos + j < count; j++) {
          ch.steps[pos + j].on = false;
        }
        pos += span;
      } else {
        pos++;
      }
    }

    deselectStep(c);
  }

  // Sync patternLength to the random count
  patterns[currentPatternIdx].patternLength = count;
  var lenEl = document.getElementById('patLen');
  if (lenEl) lenEl.value = count;

  buildUI();
  document.getElementById('status').textContent = 'RANDOM: ' + count + ' steps / density ' + Math.round(density * 100) + '%';
}

document.getElementById('btnRandom').onclick = generateRandom;

// ============================================================
//  SETTINGS MODAL (COLOR)
// ============================================================
// ============================================================
//  SETTINGS — Color Theme Presets
// ============================================================
var COLOR_THEMES = {
  /* ── Dark (vivid neon on deep purple) ── */
  dark: {
    bg: '#1a1a2e', panel: '#1e1e38', step: '#2a2a4a', ch: ['#f72585', '#a855f7', '#4cc9f0'],
    input: '#222238', border: '#444', borderDim: '#333', text: '#eee', textDim: '#aaa', textMuted: '#666', canvas: '#12122a',
    freqClr: '#f0c040', volClr: '#8a8a9a', panClr: '#6ee7b7', accent: '#4cc9f0', accentText: '#111', accentActive: '#f72585',
    btnText: '#111',
    btns: { play:'#4cc9f0', song:'#22c55e', stop:'#2a2a4a', clear:'#2a2a4a', export:'#a78bfa', save:'#38bdf8', load:'#2a2a4a', random:'#fb923c', settings:'#64748b', vary:'#f472b6', score:'#2dd4bf', wav:'#facc15', mp3:'#f87171' }
  },
  /* ── Teal (warm gold + cool cyan on deep teal) ── */
  teal: {
    bg: '#083d53', panel: '#0a4d65', step: '#0d5f7a', ch: ['#caa637', '#9ac9d8', '#effcff'],
    input: '#062f42', border: '#1a7a9a', borderDim: '#0d5570', text: '#effcff', textDim: '#9ac9d8', textMuted: '#507080', canvas: '#04293a',
    freqClr: '#caa637', volClr: '#7a9a9a', panClr: '#64f8ec', accent: '#9ac9d8', accentText: '#062f42', accentActive: '#caa637',
    btnText: '#062f42',
    btns: { play:'#67e8f9', song:'#5eead4', stop:'#0d5f7a', clear:'#0d5f7a', export:'#a5b4fc', save:'#7dd3fc', load:'#0d5f7a', random:'#e0b040', settings:'#5f8a9a', vary:'#f9a8d4', score:'#34d399', wav:'#fbbf24', mp3:'#fb7185' }
  },
  /* ── Ocean (cool blue family on deep navy) ── */
  ocean: {
    bg: '#0a1a3a', panel: '#0e2248', step: '#142c5a', ch: ['#409bdc', '#3576b1', '#fdffff'],
    input: '#081438', border: '#206ab1', borderDim: '#153060', text: '#fdffff', textDim: '#409bdc', textMuted: '#3576b1', canvas: '#060f2a',
    freqClr: '#70b8e8', volClr: '#5a7aa0', panClr: '#90d0f0', accent: '#409bdc', accentText: '#081438', accentActive: '#fdffff',
    btnText: '#081438',
    btns: { play:'#60a5fa', song:'#4ade80', stop:'#142c5a', clear:'#142c5a', export:'#a5b4fc', save:'#22d3ee', load:'#142c5a', random:'#fbbf24', settings:'#5a7a9a', vary:'#f9a8d4', score:'#5eead4', wav:'#fcd34d', mp3:'#fca5a5' }
  },
  /* ── Light (pastel buttons on cool gray) ── */
  light: {
    bg: '#e8e8f0', panel: '#f5f5fa', step: '#dcdce8', ch: ['#d6336c', '#7c3aed', '#0891b2'],
    input: '#ffffff', border: '#bbb', borderDim: '#ccc', text: '#222', textDim: '#555', textMuted: '#888', canvas: '#f0f0f8',
    freqClr: '#b07020', volClr: '#777', panClr: '#0891b2', accent: '#7c3aed', accentText: '#fff', accentActive: '#d6336c',
    btnText: '#3a3a3a',
    btns: { play:'#C8E6C9', song:'#A5D6A7', stop:'#FFCDD2', clear:'#EF9A9A', export:'#D1C4E9', save:'#CE93D8', load:'#E1BEE7', random:'#FFE0B2', settings:'#CFD8DC', vary:'#F8BBD0', score:'#B2EBF2', wav:'#FFF9C4', mp3:'#FFCCBC' }
  },
  /* ── Sakura (pastel buttons on pink) ── */
  sakura: {
    bg: '#f9ecf6', panel: '#fff1f5', step: '#f0dde8', ch: ['#f14d51', '#0000e5', '#f55487'],
    input: '#ffffff', border: '#d4b0c8', borderDim: '#e0c8d8', text: '#1a0a14', textDim: '#6a3a58', textMuted: '#a07890', canvas: '#fff8fb',
    freqClr: '#c03030', volClr: '#8a6878', panClr: '#0000c0', accent: '#f14d51', accentText: '#fff', accentActive: '#0000e5',
    btnText: '#3a3a3a',
    btns: { play:'#C8E6C9', song:'#A5D6A7', stop:'#FFCDD2', clear:'#EF9A9A', export:'#D1C4E9', save:'#CE93D8', load:'#E1BEE7', random:'#FFE0B2', settings:'#CFD8DC', vary:'#F8BBD0', score:'#B2EBF2', wav:'#FFF9C4', mp3:'#FFCCBC' }
  },
  /* ── Mint (fresh aqua + lavender accent) ── */
  mint: {
    bg: '#e8f5e9', panel: '#f1f8f2', step: '#d5ecd7', ch: ['#2e7d32', '#00897b', '#5c6bc0'],
    input: '#ffffff', border: '#a5d6a7', borderDim: '#c8e6c9', text: '#1b3a1d', textDim: '#4a6a4d', textMuted: '#7a9a7d', canvas: '#f5fbf5',
    freqClr: '#2e7d32', volClr: '#5a7a5d', panClr: '#5c6bc0', accent: '#00897b', accentText: '#fff', accentActive: '#2e7d32',
    btnText: '#16A085', btnBorder: '#A3E4D7', btnRadius: '8px', btnHover: '0.95',
    btns: {
      play:'#E8F8F5', playTx:'#16A085', song:'#D5F5E3', songTx:'#1E8449',
      stop:'#F5EEF8', stopTx:'#8E44AD', clear:'#EBDEF0', clearTx:'#7D3C98',
      export:'#EAFAF1', exportTx:'#27AE60', save:'#D4EFDF', saveTx:'#1E8449', load:'#E8F8F5', loadTx:'#17A589',
      random:'#FEF9E7', randomTx:'#B7950B', settings:'#F2F3F4', settingsTx:'#626567',
      vary:'#FADBD8', varyTx:'#C0392B', score:'#EBF5FB', scoreTx:'#2E86C1',
      wav:'#FEF5E7', wavTx:'#CA6F1E', mp3:'#FDEDEC', mp3Tx:'#E74C3C'
    }
  },
  /* ── Sky (clean pastel blue, flat) ── */
  sky: {
    bg: '#e3f2fd', panel: '#f0f7ff', step: '#d0e8fa', ch: ['#1565c0', '#e65100', '#2e7d32'],
    input: '#ffffff', border: '#90caf9', borderDim: '#bbdefb', text: '#0d2137', textDim: '#3a5a7a', textMuted: '#7090b0', canvas: '#f5faff',
    freqClr: '#1565c0', volClr: '#607a9a', panClr: '#2e7d32', accent: '#1565c0', accentText: '#fff', accentActive: '#e65100',
    btnText: '#2874A6', btnBorder: '#AED6F1', btnRadius: '6px', btnHover: '0.95',
    btns: {
      play:'#EBF5FB', playTx:'#2874A6', song:'#D6EAF8', songTx:'#2471A3',
      stop:'#FDEDEC', stopTx:'#CB4335', clear:'#FADBD8', clearTx:'#B03A2E',
      export:'#EAF2F8', exportTx:'#5499C7', save:'#D4E6F1', saveTx:'#2E86C1', load:'#EBF5FB', loadTx:'#5DADE2',
      random:'#FEF9E7', randomTx:'#B7950B', settings:'#F2F4F4', settingsTx:'#717D7E',
      vary:'#F4ECF7', varyTx:'#7D3C98', score:'#E8F8F5', scoreTx:'#17A589',
      wav:'#FEF5E7', wavTx:'#CA6F1E', mp3:'#FDEDEC', mp3Tx:'#CB4335'
    }
  },
  /* ── Cream (organic warm, dusty tones) ── */
  cream: {
    bg: '#fdf6e3', panel: '#fff9ed', step: '#f0e8d5', ch: ['#cb4b16', '#268bd2', '#6a7f00'],
    input: '#fffdf5', border: '#d9c8a0', borderDim: '#e8dcc0', text: '#3a3020', textDim: '#6a5a40', textMuted: '#9a8a70', canvas: '#fffcf4',
    freqClr: '#cb4b16', volClr: '#8a7a60', panClr: '#268bd2', accent: '#268bd2', accentText: '#fff', accentActive: '#cb4b16',
    btnText: '#A04000', btnBorder: '#D5DBDB', btnRadius: '6px', btnHover: '0.97',
    btns: {
      play:'#FDF2E9', playTx:'#A04000', song:'#FAE5D3', songTx:'#935116',
      stop:'#F9EBEA', stopTx:'#922B21', clear:'#F2D7D5', clearTx:'#7B241C',
      export:'#F4F6F6', exportTx:'#566573', save:'#EAEDED', saveTx:'#515A5A', load:'#F4F6F6', loadTx:'#717D7E',
      random:'#FDEBD0', randomTx:'#CA6F1E', settings:'#F2F3F4', settingsTx:'#626567',
      vary:'#FADBD8', varyTx:'#A93226', score:'#E8F6F3', scoreTx:'#1A7A6D',
      wav:'#FCF3CF', wavTx:'#9A7D0A', mp3:'#F6DDCC', mp3Tx:'#A04000'
    }
  },
  /* ── Lavender (dreamy soft on pale purple) ── */
  lavender: {
    bg: '#f0e6ff', panel: '#f8f2ff', step: '#e4d6f5', ch: ['#7c4dff', '#c020d0', '#00bfa5'],
    input: '#ffffff', border: '#c9b0e8', borderDim: '#ddd0f0', text: '#1a0e2e', textDim: '#5a3a80', textMuted: '#9070b8', canvas: '#faf5ff',
    freqClr: '#7c4dff', volClr: '#806898', panClr: '#00bfa5', accent: '#7c4dff', accentText: '#fff', accentActive: '#c020d0',
    btnText: '#fff',
    btns: { play:'#7c5ce8', song:'#34d399', stop:'#9070b8', clear:'#a080c0', export:'#a855f7', save:'#60a5fa', load:'#c9b0e8', random:'#fb923c', settings:'#8070a0', vary:'#d946ef', score:'#2dd4bf', wav:'#f59e0b', mp3:'#f87171' }
  },
  /* ── Peach (warm soft on light peach) ── */
  peach: {
    bg: '#fff3e0', panel: '#fff8f0', step: '#ffe8cc', ch: ['#e65100', '#ad1457', '#00695c'],
    input: '#ffffff', border: '#ffcc80', borderDim: '#ffe0b0', text: '#3e2010', textDim: '#7a5030', textMuted: '#a07850', canvas: '#fffbf5',
    freqClr: '#e65100', volClr: '#907050', panClr: '#00695c', accent: '#ad1457', accentText: '#fff', accentActive: '#e65100',
    btnText: '#fff',
    btns: { play:'#3b82f6', song:'#34d399', stop:'#a07850', clear:'#b08860', export:'#a78bfa', save:'#22d3ee', load:'#ffcc80', random:'#fb923c', settings:'#8a7a60', vary:'#f472b6', score:'#2dd4bf', wav:'#f59e0b', mp3:'#f87171' }
  },
};
var currentTheme = 'sakura';

function applyTheme(name) {
  var t = COLOR_THEMES[name];
  if (!t) return;
  currentTheme = name;
  var r = document.documentElement.style;
  r.setProperty('--bg-color', t.bg);
  r.setProperty('--panel-bg', t.panel);
  r.setProperty('--step-bg', t.step);
  r.setProperty('--input-bg', t.input);
  r.setProperty('--border', t.border);
  r.setProperty('--border-dim', t.borderDim);
  r.setProperty('--text', t.text);
  r.setProperty('--text-dim', t.textDim);
  r.setProperty('--text-muted', t.textMuted);
  r.setProperty('--canvas-bg', t.canvas);
  r.setProperty('--freq-color', t.freqClr);
  r.setProperty('--vol-color', t.volClr);
  r.setProperty('--pan-color', t.panClr);
  r.setProperty('--accent', t.accent);
  r.setProperty('--accent-text', t.accentText);
  r.setProperty('--accent-active', t.accentActive);
  r.setProperty('--btn-text', t.btnText || t.accentText);
  r.setProperty('--btn-border', t.btnBorder || 'transparent');
  r.setProperty('--btn-radius', t.btnRadius || '6px');
  r.setProperty('--btn-hover', t.btnHover || '0.92');
  if (t.btns) {
    var bk = ['play','song','stop','clear','export','save','load','random','settings','vary','score','wav','mp3'];
    for (var i = 0; i < bk.length; i++) {
      r.setProperty('--btn-' + bk[i], t.btns[bk[i]]);
      var txKey = bk[i] + 'Tx';
      if (t.btns[txKey]) { r.setProperty('--btn-' + bk[i] + '-tx', t.btns[txKey]); }
      else { r.removeProperty('--btn-' + bk[i] + '-tx'); }
    }
  }
  // Channel colors are FIXED regardless of theme — do NOT override
  // for (var c = 0; c < 3; c++) {
  //   r.setProperty('--color-ch' + c, t.ch[c]);
  //   CCOLORS[c] = t.ch[c];
  // }
  buildUI();
}

// ============================================================
//  SETTINGS — Modal handlers
// ============================================================
var settingsModal = document.getElementById('settingsModal');
var savedSettings = null;

function toggleAudioMode(ch) {
  if (ch === undefined) ch = 0;
  globalAudioMode[ch] = !globalAudioMode[ch];
  buildUI();
  buildRTUI();
}

function toggleMute(ch) {
  chMute[ch] = !chMute[ch];
  // Stop any currently playing audio on muted channel
  if (chMute[ch] && activeAudio[ch]) {
    try { activeAudio[ch].osc.stop(); } catch(e) {}
    activeAudio[ch] = null;
  }
  buildUI();
  buildRTUI();
  var name = ch < 3 ? CNAME[ch] : RT_CNAME;
  document.getElementById('status').textContent = name + (chMute[ch] ? ' MUTED' : ' UNMUTED');
}

document.getElementById('btnSettings').onclick = function() {
  savedSettings = { theme: currentTheme };
  var sel = document.getElementById('cfgTheme');
  if (sel) sel.value = currentTheme;
  settingsModal.classList.add('open');
};

document.getElementById('settingsClose').onclick = function() {
  savedSettings = null;
  settingsModal.classList.remove('open');
};

document.getElementById('settingsCancel').onclick = function() {
  if (savedSettings) {
    applyTheme(savedSettings.theme);
  }
  savedSettings = null;
  settingsModal.classList.remove('open');
};

settingsModal.addEventListener('click', function(e) {
  if (e.target === settingsModal) {
    if (savedSettings) {
      applyTheme(savedSettings.theme);
    }
    savedSettings = null;
    settingsModal.classList.remove('open');
  }
});

document.getElementById('cfgTheme').addEventListener('change', function() {
  applyTheme(this.value);
});

// ============================================================
//  KEYBOARD HANDLERS
// ============================================================
document.addEventListener('keydown', function(e) {
  var tag = document.activeElement && document.activeElement.tagName;
  if (tag === 'INPUT' || tag === 'SELECT' || tag === 'TEXTAREA') return;

  // Cmd+S: save project
  if ((e.metaKey || e.ctrlKey) && e.key === 's') {
    e.preventDefault();
    saveProject();
    return;
  }

  // Cmd+C: copy selected cell (if any) or pattern — respects lastSongFocus for back vs RT
  if ((e.metaKey || e.ctrlKey) && e.key === 'c') {
    // Check RT step first if RT is focused
    if (lastSongFocus === 'rt' && rtState[0].selectedStep >= 0) {
      var rs = rtState[0].selectedStep;
      var rstep = rtState[0].steps[rs];
      if (rstep && rstep.on) {
        cellClipboard = { wave: rstep.wave, dur: rstep.dur, channel: 'rt' };
        document.getElementById('status').textContent = 'RT cell copied (wave: ' + rstep.wave + ', dur: ' + rstep.dur + ')';
        e.preventDefault(); return;
      }
    }
    // Check back step
    for (var c = 0; c < 3; c++) {
      if (state[c].selectedStep >= 0) {
        var s = state[c].selectedStep;
        var step = state[c].steps[s];
        if (step && step.on) {
          cellClipboard = { wave: step.wave, dur: step.dur, channel: c };
          document.getElementById('status').textContent = 'Cell copied (wave: ' + step.wave + ', dur: ' + step.dur + ')';
          e.preventDefault(); return;
        }
      }
    }
    // No cell selected: copy whole pattern
    if (lastSongFocus === 'rt') {
      patternClipboard = { type: 'rt', data: JSON.parse(JSON.stringify(rtPatterns[currentRTPatternIdx])) };
      document.getElementById('status').textContent = 'RT Pattern ' + rtPatterns[currentRTPatternIdx].name + ' copied';
    } else {
      patternClipboard = { type: 'back', data: JSON.parse(JSON.stringify(patterns[currentPatternIdx])) };
      document.getElementById('status').textContent = 'Pattern ' + patterns[currentPatternIdx].name + ' copied';
    }
    e.preventDefault(); return;
  }

  // Cmd+V: paste cell or pattern — respects RT
  if ((e.metaKey || e.ctrlKey) && e.key === 'v') {
    if (cellClipboard) {
      if (cellClipboard.channel === 'rt') {
        // Paste into RT
        var nextFree = getRTNextFreeStep();
        if (nextFree >= 0 && nextFree < rtState[0].count) {
          var rstep = rtState[0].steps[nextFree];
          rstep.on = true; rstep.wave = cellClipboard.wave; rstep.dur = cellClipboard.dur;
          var avail = getAvailableDurs();
          var span = durToSteps(rstep.dur);
          while (nextFree + span > rtState[0].count) {
            var idx = avail.indexOf(rstep.dur);
            if (idx <= 0) { rstep.on = false; break; }
            rstep.dur = avail[idx - 1]; span = durToSteps(rstep.dur);
          }
          if (rstep.on) {
            selectRTStep(nextFree);
            document.getElementById('status').textContent = 'RT cell pasted at step ' + (nextFree + 1);
          }
        }
      } else {
        var cc = cellClipboard.channel;
        var nextFree = getNextFreeStep(cc);
        if (nextFree >= 0 && nextFree < state[cc].count) {
          var step = state[cc].steps[nextFree];
          step.on = true; step.wave = cellClipboard.wave; step.dur = cellClipboard.dur;
          var avail = getAvailableDurs();
          var span = durToSteps(step.dur);
          while (nextFree + span > state[cc].count) {
            var idx = avail.indexOf(step.dur);
            if (idx <= 0) { step.on = false; break; }
            step.dur = avail[idx - 1]; span = durToSteps(step.dur);
          }
          if (step.on) {
            for (var j = 1; j < span && nextFree + j < state[cc].count; j++) state[cc].steps[nextFree + j].on = false;
            selectStep(cc, nextFree);
            document.getElementById('status').textContent = 'Cell pasted at step ' + (nextFree + 1);
          }
        }
      }
    } else if (patternClipboard) {
      if (patternClipboard.type === 'rt') {
        var copy = JSON.parse(JSON.stringify(patternClipboard.data));
        var naming = nextRTCopyName(patternClipboard.data);
        copy.name = naming.name; copy.baseName = naming.baseName; copy.varySuffix = naming.varySuffix;
        rtPatterns.push(copy);
        rtSong.push({ patIdx: rtPatterns.length - 1, repeat: 1 });
        switchToRTPattern(rtPatterns.length - 1);
        selectedRTSongCell = rtSong.length - 1;
        renderRTSongLane(); renderPatternPool();
        document.getElementById('status').textContent = 'RT Pattern pasted as ' + copy.name;
      } else {
        var copy = JSON.parse(JSON.stringify(patternClipboard.data));
        var naming = nextCopyName(patternClipboard.data);
        copy.name = naming.name; copy.baseName = naming.baseName; copy.varySuffix = naming.varySuffix;
        patterns.push(copy);
        song.push({ patIdx: patterns.length - 1, repeat: 1 });
        switchToPattern(patterns.length - 1);
        selectedSongCell = song.length - 1;
        renderSongLane(); renderPatternPool();
        document.getElementById('status').textContent = 'Pattern pasted as ' + copy.name;
      }
    }
    e.preventDefault(); return;
  }

  // Cmd+D: duplicate selected cell at next free position
  if ((e.metaKey || e.ctrlKey) && e.key === 'd') {
    e.preventDefault();
    // Check RT first
    if (rtState[0].selectedStep >= 0) {
      var rs = rtState[0].selectedStep;
      var rsrc = rtState[0].steps[rs];
      if (rsrc && rsrc.on) {
        var nextFree = getRTNextFreeStep();
        if (nextFree >= 0 && nextFree < rtState[0].count) {
          var tgt = rtState[0].steps[nextFree];
          tgt.on = true; tgt.wave = rsrc.wave; tgt.dur = rsrc.dur;
          var avail = getAvailableDurs();
          var span = durToSteps(tgt.dur);
          while (nextFree + span > rtState[0].count) {
            var idx = avail.indexOf(tgt.dur);
            if (idx <= 0) { tgt.on = false; break; }
            tgt.dur = avail[idx - 1]; span = durToSteps(tgt.dur);
          }
          if (tgt.on) {
            selectRTStep(nextFree);
            document.getElementById('status').textContent = 'RT cell duplicated at step ' + (nextFree + 1);
          }
        }
      }
      return;
    }
    for (var c = 0; c < 3; c++) {
      if (state[c].selectedStep >= 0) {
        var s = state[c].selectedStep;
        var srcStep = state[c].steps[s];
        if (srcStep && srcStep.on) {
          var nextFree = getNextFreeStep(c);
          if (nextFree >= 0 && nextFree < state[c].count) {
            var tgt = state[c].steps[nextFree];
            tgt.on = true;
            tgt.wave = srcStep.wave;
            tgt.dur = srcStep.dur;
            var avail = getAvailableDurs();
            var span = durToSteps(tgt.dur);
            while (nextFree + span > state[c].count) {
              var idx = avail.indexOf(tgt.dur);
              if (idx <= 0) { tgt.on = false; break; }
              tgt.dur = avail[idx - 1];
              span = durToSteps(tgt.dur);
            }
            if (tgt.on) {
              for (var j = 1; j < span && nextFree + j < state[c].count; j++) {
                state[c].steps[nextFree + j].on = false;
              }
              selectStep(c, nextFree);
              document.getElementById('status').textContent = 'Cell duplicated at step ' + (nextFree + 1);
            }
          }
        }
        return;
      }
    }
    return;
  }

  // Spacebar: pattern play/stop, Shift+Space: song play/stop
  if (e.key === ' ' || e.code === 'Space') {
    e.preventDefault();
    if (e.shiftKey) {
      if (songPlaying) doStop(false);
      else doSongPlay();
    } else {
      if (isPlaying || songPlaying) doStop(false);
      else doPlay();
    }
    return;
  }

  // Delete/Backspace: clear range-selected steps, single selected step, or remove song cell
  if (e.key === 'Delete' || e.key === 'Backspace') {
    // 1. RT range selection
    if (rtRangeSelection.steps.length > 1) {
      rtRangeSelection.steps.forEach(function(s) { rtState[0].steps[s].on = false; });
      var count = rtRangeSelection.steps.length;
      rtRangeSelection = { steps: [] };
      deselectRTStep(); renderRTGrid(); renderRTEventChain();
      document.getElementById('status').textContent = count + ' RT cells deleted';
      e.preventDefault(); return;
    }
    // 2. Back range selection
    if (rangeSelection.channel >= 0 && rangeSelection.steps.length > 1) {
      var rc = rangeSelection.channel;
      rangeSelection.steps.forEach(function(s) { state[rc].steps[s].on = false; });
      var count = rangeSelection.steps.length;
      rangeSelection = { channel: -1, steps: [] };
      deselectStep(rc); renderSplitGrid(); renderEventChain(rc);
      document.getElementById('status').textContent = count + ' cells deleted';
      e.preventDefault(); return;
    }
    // 3. RT single selected step
    if (rtState[0].selectedStep >= 0) {
      rtState[0].steps[rtState[0].selectedStep].on = false;
      rtRangeSelection = { steps: [] };
      deselectRTStep(); renderRTGrid(); renderRTEventChain();
      e.preventDefault(); return;
    }
    // 4. Back single selected step
    for (var c = 0; c < 3; c++) {
      if (state[c].selectedStep >= 0) {
        state[c].steps[state[c].selectedStep].on = false;
        rangeSelection = { channel: -1, steps: [] };
        deselectStep(c); renderSplitGrid(); renderEventChain(c);
        e.preventDefault(); return;
      }
    }
    // 5. Song/Pool cell deletion based on lastSongFocus
    // 5a. Pool cell selected (not song cell)
    if (lastSongFocus === 'back' && selectedPoolIdx >= 0 && selectedSongCell < 0) {
      deletePoolPattern('back', selectedPoolIdx);
      e.preventDefault(); return;
    }
    if (lastSongFocus === 'rt' && selectedRTPoolIdx >= 0 && selectedRTSongCell < 0) {
      deletePoolPattern('rt', selectedRTPoolIdx);
      e.preventDefault(); return;
    }
    // 5b. Song cell
    if (lastSongFocus === 'rt' && selectedRTSongCell >= 0 && selectedRTSongCell < rtSong.length) {
      if (rtSong.length > 1) {
        rtSong.splice(selectedRTSongCell, 1);
        if (selectedRTSongCell >= rtSong.length) selectedRTSongCell = rtSong.length - 1;
        if (songPlayhead >= rtSong.length) songPlayhead = Math.min(songPlayhead, rtSong.length - 1);
        renderRTSongLane(); renderPatternPool();
      }
      e.preventDefault(); return;
    }
    if (lastSongFocus === 'back' && selectedSongCell >= 0 && selectedSongCell < song.length) {
      if (song.length > 1) {
        song.splice(selectedSongCell, 1);
        if (selectedSongCell >= song.length) selectedSongCell = song.length - 1;
        if (songPlayhead >= song.length) songPlayhead = song.length - 1;
        switchToPattern(song[Math.max(0, selectedSongCell)].patIdx);
        renderSongLane(); renderPatternPool();
      }
      e.preventDefault(); return;
    }
  }
});

// (Quantize change listener removed — fixed at 96 ticks/bar)

// ============================================================
//  WINDOW RESIZE → REDRAW GRID
// ============================================================
var resizeTimer = null;
window.addEventListener('resize', function() {
  clearTimeout(resizeTimer);
  resizeTimer = setTimeout(function() {
    renderSplitGrid();
  }, 200);
});

// ============================================================
//  VARY — Modal open/close
// ============================================================
document.getElementById('btnVary').onclick = function() {
  document.getElementById('varyModal').classList.add('open');
};
document.getElementById('varyClose').onclick = function() {
  document.getElementById('varyModal').classList.remove('open');
};
document.getElementById('varyModal').addEventListener('click', function(e) {
  if (e.target === this) this.classList.remove('open');
});

// ============================================================
//  VARY — Helpers
// ============================================================
function deepCopyChannels(src) {
  return JSON.parse(JSON.stringify(src));
}

function cloneStepArr(arr) {
  return arr.map(function(s) { return { on: s.on, wave: s.wave, dur: s.dur }; });
}

function randWave() {
  return WAVE_IDS[Math.floor(Math.random() * WAVE_IDS.length)];
}
function randDur() {
  var avail = getAvailableDurs();
  return avail[Math.floor(Math.random() * avail.length)];
}

// Wave inversion map
var WAVE_INVERT = {
  ramp_up: 'ramp_down', ramp_down: 'ramp_up',
  triangle: 'inv_triangle', inv_triangle: 'triangle',
  high: 'low', low: 'high',
  square: 'square'
};

// Bjorklund / Euclidean rhythm algorithm
function bjorklund(pulses, steps) {
  if (pulses >= steps) {
    var res = [];
    for (var i = 0; i < steps; i++) res.push(1);
    return res;
  }
  if (pulses === 0) {
    var res = [];
    for (var i = 0; i < steps; i++) res.push(0);
    return res;
  }
  var pattern = [];
  for (var i = 0; i < steps; i++) pattern.push(i < pulses ? [1] : [0]);
  var level = 0;
  while (true) {
    var counts = 0;
    var remainder = pattern.length - pulses;
    if (remainder <= 1) break;
    var newPat = [];
    var minLen = Math.min(pulses, remainder);
    for (var i = 0; i < minLen; i++) {
      newPat.push(pattern[i].concat(pattern[pulses + i]));
    }
    if (pulses > remainder) {
      for (var i = minLen; i < pulses; i++) newPat.push(pattern[i]);
      pulses = remainder;
    } else {
      for (var i = pulses + minLen; i < pattern.length; i++) newPat.push(pattern[i]);
      pulses = minLen;
    }
    pattern = newPat;
    level++;
    if (level > 100) break;
  }
  var flat = [];
  for (var i = 0; i < pattern.length; i++)
    for (var j = 0; j < pattern[i].length; j++)
      flat.push(pattern[i][j]);
  return flat;
}

// ============================================================
//  VARY — Suffix map for naming
// ============================================================
var VARY_SUFFIX = {
  reverse: 'r', inversion: 'i', retro_inv: 'ri',
  augment: '+', diminish: '-', rotate: '⟳',
  half_swap: '↔', mirror: 'm',
  density_up: 'd+', density_down: 'd-',
  wave_mutate: 'w', dur_shuffle: 'ds',
  call_response: 'cr', echo: 'e',
  euclidean: 'E', syncopation: 'sy',
  phase_shift: 'ps', additive: 'a+', subtractive: 'a-',
  humanize: 'h', chaos: '*',
  ch_swap_12: 'x12', ch_swap_13: 'x13', ch_swap_23: 'x23',
  single_ch: '1v', tihai: 'T'
};

// ============================================================
//  VARY — Apply variation → create new pattern in song
// ============================================================
function doVary(type) {
  var src = deepCopyChannels(state);
  var q = getQuant();
  var max = getMax();
  var avail = getAvailableDurs();

  // Parameter inputs
  var rotateN = parseInt(document.getElementById('vRotate').value) || 2;
  var echoDelay = parseInt(document.getElementById('vEcho').value) || 2;
  var chaosPercent = parseInt(document.getElementById('vChaos').value) || 30;

  // Apply the variation to src
  switch (type) {

    // ============ 1. REVERSE ============
    case 'reverse':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        var events = [];
        for (var i = 0; i < count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur });
          }
        }
        events.reverse();
        for (var i = 0; i < max; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }
        var pos = 0;
        for (var e = 0; e < events.length; e++) {
          pos = snapToGrid(pos, events[e].dur, count);
          var span = q / events[e].dur;
          if (pos + span > count) break;
          ch.steps[pos].on = true;
          ch.steps[pos].wave = events[e].wave;
          ch.steps[pos].dur = events[e].dur;
          pos += span;
        }
      }
      break;

    // ============ 2. INVERSION ============
    case 'inversion':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            ch.steps[i].wave = WAVE_INVERT[ch.steps[i].wave] || ch.steps[i].wave;
          }
        }
      }
      break;

    // ============ 3. RETROGRADE INVERSION ============
    case 'retro_inv':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        var events = [];
        for (var i = 0; i < count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            events.push({ wave: WAVE_INVERT[ch.steps[i].wave] || ch.steps[i].wave, dur: ch.steps[i].dur });
          }
        }
        events.reverse();
        for (var i = 0; i < max; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }
        var pos = 0;
        for (var e = 0; e < events.length; e++) {
          pos = snapToGrid(pos, events[e].dur, count);
          var span = q / events[e].dur;
          if (pos + span > count) break;
          ch.steps[pos].on = true;
          ch.steps[pos].wave = events[e].wave;
          ch.steps[pos].dur = events[e].dur;
          pos += span;
        }
      }
      break;

    // ============ 4. AUGMENT ============
    case 'augment':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        // Double durations (halve dur value = double length)
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            var newDur = ch.steps[i].dur / 2;
            // Find closest available dur that's ≤ current
            if (avail.indexOf(newDur) !== -1) {
              ch.steps[i].dur = newDur;
            } else {
              // Find lowest available (longest duration)
              ch.steps[i].dur = avail[avail.length - 1];
            }
          }
        }
        // Re-lay events to avoid overlap
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 5. DIMINISH ============
    case 'diminish':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            var newDur = ch.steps[i].dur * 2;
            if (avail.indexOf(newDur) !== -1) {
              ch.steps[i].dur = newDur;
            } else {
              ch.steps[i].dur = avail[0]; // shortest
            }
          }
        }
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 6. ROTATION ============
    case 'rotate':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        var copy = cloneStepArr(ch.steps.slice(0, count));
        for (var i = 0; i < count; i++) {
          var from = (i - rotateN % count + count) % count;
          ch.steps[i] = copy[from];
        }
      }
      break;

    // ============ 7. HALF SWAP ============
    case 'half_swap':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var half = Math.floor(ch.count / 2);
        var copy = cloneStepArr(ch.steps.slice(0, ch.count));
        for (var i = 0; i < half; i++) {
          ch.steps[i] = copy[half + i];
        }
        for (var i = half; i < ch.count; i++) {
          ch.steps[i] = copy[i - half];
        }
      }
      break;

    // ============ 8. MIRROR ============
    case 'mirror':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var half = Math.floor(ch.count / 2);
        // Copy first half to second half in reverse
        for (var i = 0; i < half; i++) {
          var mirrorIdx = ch.count - 1 - i;
          if (mirrorIdx < ch.count && ch.steps[i]) {
            ch.steps[mirrorIdx] = { on: ch.steps[i].on, wave: ch.steps[i].wave, dur: ch.steps[i].dur };
          }
        }
      }
      break;

    // ============ 9. DENSITY+ ============
    case 'density_up':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var blocked = computeBlockedSrc(ch, q, max);
        for (var i = 0; i < ch.count; i++) {
          // Only add at grid-aligned positions
          if (i % 2 !== 0 && i % 3 !== 0) continue;
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          if (!ch.steps[i].on && !blocked[i] && Math.random() < 0.35) {
            // Pick duration matching this grid position
            var compatDurs = [];
            for (var d = 0; d < avail.length; d++) {
              if (i % 3 === 0 && isNormalDur(avail[d])) compatDurs.push(avail[d]);
              else if (i % 2 === 0 && isTripletDur(avail[d])) compatDurs.push(avail[d]);
            }
            if (compatDurs.length === 0) continue;
            ch.steps[i].on = true;
            ch.steps[i].wave = randWave();
            ch.steps[i].dur = compatDurs[Math.floor(Math.random() * Math.min(3, compatDurs.length))];
          }
        }
      }
      break;

    // ============ 10. DENSITY- ============
    case 'density_down':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on && Math.random() < 0.4) {
            ch.steps[i].on = false;
          }
        }
      }
      break;

    // ============ 11. WAVE MUTATE ============
    case 'wave_mutate':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            ch.steps[i].wave = randWave();
          }
        }
      }
      break;

    // ============ 12. DURATION SHUFFLE ============
    case 'dur_shuffle':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var durs = [];
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on) durs.push(ch.steps[i].dur);
        }
        // Fisher-Yates shuffle
        for (var i = durs.length - 1; i > 0; i--) {
          var j = Math.floor(Math.random() * (i + 1));
          var tmp = durs[i]; durs[i] = durs[j]; durs[j] = tmp;
        }
        var di = 0;
        // collect events, assign shuffled durations, re-lay
        var events = [];
        for (var i = 0; i < ch.count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            events.push({ wave: ch.steps[i].wave, dur: durs[di++] });
          }
        }
        // clear
        for (var i = 0; i < max; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }
        var pos = 0;
        for (var e = 0; e < events.length; e++) {
          pos = snapToGrid(pos, events[e].dur, ch.count);
          var span = q / events[e].dur;
          if (pos + span > ch.count) break;
          ch.steps[pos].on = true;
          ch.steps[pos].wave = events[e].wave;
          ch.steps[pos].dur = events[e].dur;
          pos += span;
        }
      }
      break;

    // ============ 13. CALL & RESPONSE ============
    case 'call_response':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        for (var i = 0; i < ch.count; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          if (ch.steps[i].on) {
            ch.steps[i].on = false;
          } else {
            ch.steps[i].on = true;
            ch.steps[i].wave = randWave();
            ch.steps[i].dur = avail[0]; // shortest dur for response
          }
        }
        // Need to fix overlaps — re-lay
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 14. ECHO ============
    case 'echo':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var origSteps = cloneStepArr(ch.steps.slice(0, ch.count));
        for (var i = 0; i < ch.count; i++) {
          var srcIdx = i - echoDelay;
          if (srcIdx >= 0 && origSteps[srcIdx] && origSteps[srcIdx].on && (!ch.steps[i] || !ch.steps[i].on)) {
            if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
            ch.steps[i].on = true;
            ch.steps[i].wave = origSteps[srcIdx].wave;
            ch.steps[i].dur = origSteps[srcIdx].dur;
          }
        }
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 15. EUCLIDEAN ============
    case 'euclidean':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        // Count existing events to use as pulse count
        var eventCount = 0;
        for (var i = 0; i < count; i++) {
          if (ch.steps[i] && ch.steps[i].on) eventCount++;
        }
        if (eventCount === 0) eventCount = Math.max(1, Math.floor(count / 4));
        var rhythm = bjorklund(eventCount, count);
        // Collect waves from original to reuse
        var waves = [];
        for (var i = 0; i < count; i++) {
          if (ch.steps[i] && ch.steps[i].on) waves.push(ch.steps[i].wave);
        }
        // Clear
        for (var i = 0; i < max; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }
        // Apply euclidean rhythm
        var wi = 0;
        for (var i = 0; i < count; i++) {
          if (rhythm[i]) {
            ch.steps[i].on = true;
            ch.steps[i].wave = waves[wi % waves.length] || randWave();
            ch.steps[i].dur = avail[0]; // shortest
            wi++;
          }
        }
      }
      break;

    // ============ 16. SYNCOPATION ============
    case 'syncopation':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        var beatStep = (q === 96) ? 24 : 4; // steps per beat
        var origSteps = cloneStepArr(ch.steps.slice(0, count));
        // Clear
        for (var i = 0; i < count; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }
        for (var i = 0; i < count; i++) {
          if (origSteps[i] && origSteps[i].on) {
            var isBeatHead = (i % beatStep === 0);
            var newPos;
            if (isBeatHead) {
              // Shift to offbeat (half beat later)
              newPos = i + Math.floor(beatStep / 2);
            } else {
              newPos = i; // keep offbeats as-is
            }
            if (newPos < count) {
              ch.steps[newPos].on = true;
              ch.steps[newPos].wave = origSteps[i].wave;
              ch.steps[newPos].dur = origSteps[i].dur;
            }
          }
        }
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 17. PHASE SHIFT ============
    case 'phase_shift':
      // Generate multiple patterns: ch0 stays, ch1 shifts +1, ch2 shifts +2
      // Creates 3 patterns in song showing gradual shift
      varyMultiPattern(src, q, max, avail, function(channels, idx) {
        for (var c = 0; c < 3; c++) {
          var ch = channels[c];
          var count = ch.count;
          var copy = cloneStepArr(ch.steps.slice(0, count));
          var shift = c * (idx + 1);
          for (var i = 0; i < count; i++) {
            var from = (i - shift % count + count) % count;
            ch.steps[i] = copy[from];
          }
        }
      }, 3, type);
      return; // varyMultiPattern handles pattern creation

    // ============ 18. ADDITIVE PROCESS ============
    case 'additive':
      // Create patterns that progressively add events
      var totalEvents = 0;
      for (var c = 0; c < 3; c++) {
        for (var i = 0; i < src[c].count; i++) {
          if (src[c].steps[i] && src[c].steps[i].on) totalEvents++;
        }
      }
      var numPats = Math.min(totalEvents, 6);
      if (numPats < 2) numPats = 2;
      varyMultiPattern(src, q, max, avail, function(channels, idx) {
        var frac = (idx + 1) / numPats;
        for (var c = 0; c < 3; c++) {
          var ch = channels[c];
          for (var i = 0; i < ch.count; i++) {
            if (ch.steps[i] && ch.steps[i].on) {
              if (Math.random() > frac) ch.steps[i].on = false;
            }
          }
        }
      }, numPats, type);
      return;

    // ============ 19. SUBTRACTIVE PROCESS ============
    case 'subtractive':
      var totalEvents2 = 0;
      for (var c = 0; c < 3; c++) {
        for (var i = 0; i < src[c].count; i++) {
          if (src[c].steps[i] && src[c].steps[i].on) totalEvents2++;
        }
      }
      var numPats2 = Math.min(totalEvents2, 6);
      if (numPats2 < 2) numPats2 = 2;
      varyMultiPattern(src, q, max, avail, function(channels, idx) {
        var frac = idx / numPats2;
        for (var c = 0; c < 3; c++) {
          var ch = channels[c];
          for (var i = 0; i < ch.count; i++) {
            if (ch.steps[i] && ch.steps[i].on) {
              if (Math.random() < frac) ch.steps[i].on = false;
            }
          }
        }
      }, numPats2, type);
      return;

    // ============ 20. HUMANIZE ============
    case 'humanize':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        var origSteps = cloneStepArr(ch.steps.slice(0, count));
        // Clear
        for (var i = 0; i < count; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }
        for (var i = 0; i < count; i++) {
          if (origSteps[i] && origSteps[i].on) {
            var shift = Math.floor(Math.random() * 3) - 1; // -1, 0, +1
            var newPos = Math.max(0, Math.min(count - 1, i + shift));
            if (!ch.steps[newPos].on) {
              ch.steps[newPos].on = true;
              ch.steps[newPos].wave = origSteps[i].wave;
              // Possibly adjust duration ±1 step
              var durIdx = avail.indexOf(origSteps[i].dur);
              if (durIdx !== -1 && Math.random() < 0.3) {
                var shift2 = Math.random() < 0.5 ? -1 : 1;
                var newIdx = Math.max(0, Math.min(avail.length - 1, durIdx + shift2));
                ch.steps[newPos].dur = avail[newIdx];
              } else {
                ch.steps[newPos].dur = origSteps[i].dur;
              }
            } else {
              // Position taken, keep original
              ch.steps[i].on = true;
              ch.steps[i].wave = origSteps[i].wave;
              ch.steps[i].dur = origSteps[i].dur;
            }
          }
        }
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 21. CHAOS ============
    case 'chaos':
      var chaos = chaosPercent / 100;
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        for (var i = 0; i < ch.count; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          if (Math.random() < chaos) {
            // Mutate this step
            ch.steps[i].on = !ch.steps[i].on;
            if (ch.steps[i].on) {
              if (Math.random() < 0.5) ch.steps[i].wave = randWave();
              if (Math.random() < 0.5) ch.steps[i].dur = randDur();
            }
          }
        }
        varyRelayout(ch, q, max);
      }
      break;

    // ============ 22-23. CHANNEL SWAP ============
    case 'ch_swap_12':
      var tmp = deepCopyChannels([src[0]])[0];
      src[0] = deepCopyChannels([src[1]])[0];
      src[1] = tmp;
      // Preserve per-channel metadata
      varySwapMeta(src, 0, 1);
      break;

    case 'ch_swap_13':
      var tmp = deepCopyChannels([src[0]])[0];
      src[0] = deepCopyChannels([src[2]])[0];
      src[2] = tmp;
      varySwapMeta(src, 0, 2);
      break;

    case 'ch_swap_23':
      var tmp = deepCopyChannels([src[1]])[0];
      src[1] = deepCopyChannels([src[2]])[0];
      src[2] = tmp;
      varySwapMeta(src, 1, 2);
      break;

    // ============ 23.5 SINGLE CH VARIATION ============
    case 'single_ch':
      // Pick a random channel and apply a random simple variation
      var targetCh = Math.floor(Math.random() * 3);
      var simpleVars = ['reverse', 'inversion', 'rotate', 'wave_mutate', 'density_up', 'density_down'];
      var pickVar = simpleVars[Math.floor(Math.random() * simpleVars.length)];
      // Apply to only one channel
      varySingleChannel(src[targetCh], pickVar, q, max, avail, rotateN);
      break;

    // ============ 24. TIHAI ============
    case 'tihai':
      for (var c = 0; c < 3; c++) {
        var ch = src[c];
        var count = ch.count;
        // Collect existing phrase events
        var events = [];
        for (var i = 0; i < count; i++) {
          if (ch.steps[i] && ch.steps[i].on) {
            events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur, span: Math.round(q / ch.steps[i].dur) });
          }
        }
        if (events.length === 0) continue;

        // Calculate phrase length in steps
        var phraseLen = 0;
        for (var e = 0; e < events.length; e++) phraseLen += events[e].span;
        if (phraseLen === 0) continue;

        // Tihai: repeat phrase 3 times to land on step 0 (or as close as possible)
        // Total needed = 3 * phraseLen, fit into count steps
        // If 3*phraseLen > count, trim phrase
        while (phraseLen * 3 > count && events.length > 1) {
          events.pop();
          phraseLen = 0;
          for (var e = 0; e < events.length; e++) phraseLen += events[e].span;
        }

        // Clear
        for (var i = 0; i < max; i++) {
          if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
          ch.steps[i].on = false;
        }

        // Calculate gap between repetitions to land on beat 0
        // total = 3*phraseLen + 2*gap = count (or nearest)
        var totalPhrase = 3 * phraseLen;
        var remainingSteps = count - totalPhrase;
        var gap = Math.max(0, Math.floor(remainingSteps / 2));

        // Place 3 repetitions
        var pos = 0;
        for (var rep = 0; rep < 3; rep++) {
          for (var e = 0; e < events.length; e++) {
            if (pos >= count) break;
            ch.steps[pos].on = true;
            ch.steps[pos].wave = events[e].wave;
            ch.steps[pos].dur = events[e].dur;
            pos += events[e].span;
          }
          if (rep < 2) pos += gap; // gap between repetitions
        }
      }
      break;

    default:
      break;
  }

  // Create new pattern from varied src
  varyCreatePattern(src, type);
}

// ============================================================
//  VARY — Helper: Relayout to fix overlaps
// ============================================================
function snapToGrid(pos, dur, limit) {
  var gridStep = isTripletDur(dur) ? 2 : 3;
  while (pos < limit && pos % gridStep !== 0) pos++;
  return pos;
}

function varyRelayout(ch, q, max) {
  var events = [];
  for (var i = 0; i < ch.count; i++) {
    if (ch.steps[i] && ch.steps[i].on) {
      events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur });
    }
  }
  var avail = getAvailableDurs();
  // Clear
  for (var i = 0; i < max; i++) {
    if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
    ch.steps[i].on = false;
  }
  // Re-lay sequentially with grid snapping
  var pos = 0;
  for (var e = 0; e < events.length; e++) {
    pos = snapToGrid(pos, events[e].dur, ch.count);
    var span = Math.round(q / events[e].dur);
    if (span < 1) span = 1;
    if (pos + span > ch.count) break;
    ch.steps[pos].on = true;
    ch.steps[pos].wave = events[e].wave;
    ch.steps[pos].dur = events[e].dur;
    pos += span;
  }
}

// ============================================================
//  VARY — Helper: compute blocked from src channels
// ============================================================
function computeBlockedSrc(ch, q, max) {
  var blocked = [];
  for (var i = 0; i < max; i++) blocked.push(false);
  var limit = Math.min(ch.count, max);
  for (var i = 0; i < limit; i++) {
    if (ch.steps[i] && ch.steps[i].on) {
      var span = Math.round(q / ch.steps[i].dur);
      for (var j = 1; j < span && i + j < limit; j++) {
        blocked[i + j] = true;
      }
    }
  }
  return blocked;
}

// ============================================================
//  VARY — Helper: Swap channel metadata (note, freq, pan, etc. stay with channel slot)
// ============================================================
function varySwapMeta(src, a, b) {
  // We only swapped step/pattern data. Restore note/freq/pan/volume to original channel slots.
  // Actually for a creative swap, we swap everything INCLUDING audio params.
  // So this is a no-op; both steps and params got swapped already via deepCopy.
}

// ============================================================
//  VARY — Helper: Single channel variation
// ============================================================
function varySingleChannel(ch, type, q, max, avail, rotateN) {
  switch (type) {
    case 'reverse':
      var events = [];
      for (var i = 0; i < ch.count; i++) {
        if (ch.steps[i] && ch.steps[i].on) events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur });
      }
      events.reverse();
      for (var i = 0; i < max; i++) {
        if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
        ch.steps[i].on = false;
      }
      var pos = 0;
      for (var e = 0; e < events.length; e++) {
        pos = snapToGrid(pos, events[e].dur, ch.count);
        var span = Math.round(q / events[e].dur);
        if (pos + span > ch.count) break;
        ch.steps[pos].on = true;
        ch.steps[pos].wave = events[e].wave;
        ch.steps[pos].dur = events[e].dur;
        pos += span;
      }
      break;
    case 'inversion':
      for (var i = 0; i < ch.count; i++) {
        if (ch.steps[i] && ch.steps[i].on) {
          ch.steps[i].wave = WAVE_INVERT[ch.steps[i].wave] || ch.steps[i].wave;
        }
      }
      break;
    case 'rotate':
      var count = ch.count;
      var copy = cloneStepArr(ch.steps.slice(0, count));
      for (var i = 0; i < count; i++) {
        var from = (i - rotateN % count + count) % count;
        ch.steps[i] = copy[from];
      }
      break;
    case 'wave_mutate':
      for (var i = 0; i < ch.count; i++) {
        if (ch.steps[i] && ch.steps[i].on) ch.steps[i].wave = randWave();
      }
      break;
    case 'density_up':
      var blocked = computeBlockedSrc(ch, q, max);
      for (var i = 0; i < ch.count; i++) {
        if (i % 2 !== 0 && i % 3 !== 0) continue;
        if (!ch.steps[i]) ch.steps[i] = { on: false, wave: 'ramp_up', dur: avail[0] };
        if (!ch.steps[i].on && !blocked[i] && Math.random() < 0.35) {
          var compatDurs = [];
          for (var d = 0; d < avail.length; d++) {
            if (i % 3 === 0 && isNormalDur(avail[d])) compatDurs.push(avail[d]);
            else if (i % 2 === 0 && isTripletDur(avail[d])) compatDurs.push(avail[d]);
          }
          if (compatDurs.length === 0) continue;
          ch.steps[i].on = true;
          ch.steps[i].wave = randWave();
          ch.steps[i].dur = compatDurs[Math.floor(Math.random() * Math.min(3, compatDurs.length))];
        }
      }
      break;
    case 'density_down':
      for (var i = 0; i < ch.count; i++) {
        if (ch.steps[i] && ch.steps[i].on && Math.random() < 0.4) ch.steps[i].on = false;
      }
      break;
  }
}

// ============================================================
//  VARY — Helper: Multi-pattern generation (minimalism)
// ============================================================
function varyMultiPattern(srcBase, q, max, avail, transformFn, numPats, varyType) {
  for (var p = 0; p < numPats; p++) {
    var channels = deepCopyChannels(srcBase);
    transformFn(channels, p);
    varyCreatePattern(channels, varyType);
  }
  document.getElementById('varyModal').classList.remove('open');
}

// ============================================================
//  VARY — Create pattern from varied channels
// ============================================================
function varyCreatePattern(channels, varyType) {
  var suffix = (varyType && VARY_SUFFIX[varyType]) ? VARY_SUFFIX[varyType] : '';
  var srcBase = patterns[currentPatternIdx].baseName || patterns[currentPatternIdx].name.charAt(0);
  var candidateName = srcBase + suffix;
  // Deduplicate: if name already exists, add number
  var existing = {};
  patterns.forEach(function(p) { existing[p.name] = true; });
  var finalName = candidateName;
  var dedupSuffix = suffix;
  if (existing[finalName]) {
    var n = 2;
    while (existing[srcBase + suffix + n]) n++;
    dedupSuffix = suffix + n;
    finalName = srcBase + dedupSuffix;
  }
  var pat = { name: finalName, channels: channels, baseName: srcBase, varySuffix: dedupSuffix, patternLength: patterns[currentPatternIdx].patternLength || 128 };
  patterns.push(pat);
  var newIdx = patterns.length - 1;

  // Add to song
  song.push({ patIdx: newIdx, repeat: 1 });

  // Switch to new pattern
  switchToPattern(newIdx);
  renderSongLane();
  renderPatternSelect();

  document.getElementById('varyModal').classList.remove('open');
}

// ============================================================
//  SCORE EXPORT (Plain Text)
// ============================================================
function generateScore() {
  var q = getQuant();
  var bpm = getBPM();
  var quantLabel = (q === 96) ? '96ppq' : '16th';
  var lines = [];

  lines.push('========================================');
  lines.push('  SCORE — ' + bpm + ' BPM / ' + quantLabel);
  lines.push('========================================');
  lines.push('');

  // Song line
  var songParts = [];
  for (var s = 0; s < song.length; s++) {
    var cell = song[s];
    var pat = patterns[cell.patIdx];
    var name = pat ? pat.name : '?';
    songParts.push(name + 'x' + cell.repeat);
  }
  lines.push('BACK SONG: ' + songParts.join(' > '));

  var rtSongParts = [];
  for (var s = 0; s < rtSong.length; s++) {
    var cell = rtSong[s];
    var pat = rtPatterns[cell.patIdx];
    var name = pat ? pat.name : '?';
    rtSongParts.push(name + 'x' + cell.repeat);
  }
  lines.push('RT   SONG: ' + rtSongParts.join(' > '));
  lines.push('');

  // Collect unique patterns referenced in song
  var usedPatIdx = [];
  var usedSet = {};
  for (var s = 0; s < song.length; s++) {
    var idx = song[s].patIdx;
    if (!usedSet[idx]) {
      usedSet[idx] = true;
      usedPatIdx.push(idx);
    }
  }
  // Also include current pattern if not in song
  if (!usedSet[currentPatternIdx]) {
    usedPatIdx.push(currentPatternIdx);
  }

  for (var pi = 0; pi < usedPatIdx.length; pi++) {
    var pat = patterns[usedPatIdx[pi]];
    if (!pat) continue;
    var ch = pat.channels;
    var count = pat.patternLength || ch[0].count;

    lines.push('----------------------------------------');
    lines.push('  Pattern ' + pat.name + ' (' + count + ' steps)');
    lines.push('----------------------------------------');

    for (var c = 0; c < 3; c++) {
      var channel = ch[c];
      var parts = [];

      for (var i = 0; i < channel.count; i++) {
        if (channel.steps[i] && channel.steps[i].on) {
          var dur = channel.steps[i].dur;
          var wave = channel.steps[i].wave;
          var sym = WAVE_SYM[wave] || '?';
          var durStr = durLabel(dur);
          parts.push(durStr + sym);
        }
      }

      lines.push('CH' + (c + 1) + ': ' + (parts.length > 0 ? parts.join(' ') : '(empty)'));
    }
    lines.push('');
  }

  // RT patterns
  lines.push('========== RT PATTERNS ==========');
  for (var pi = 0; pi < rtPatterns.length; pi++) {
    var rtPat = rtPatterns[pi];
    var rtCh = rtPat.channels[0];
    var rtParts = [];
    for (var i = 0; i < rtCh.count; i++) {
      if (rtCh.steps[i] && rtCh.steps[i].on) {
        rtParts.push(durLabel(rtCh.steps[i].dur) + (WAVE_SYM[rtCh.steps[i].wave] || '?'));
      }
    }
    lines.push('RT Pat ' + rtPat.name + ': ' + (rtParts.length > 0 ? rtParts.join(' ') : '(empty)'));
  }
  lines.push('');

  lines.push('========================================');

  return lines.join('\n');
}

document.getElementById('btnScore').onclick = function() {
  var text = generateScore();
  var blob = new Blob([text], { type: 'text/plain; charset=utf-8' });
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = 'score_' + getBPM() + 'bpm.txt';
  a.click();
  document.getElementById('status').textContent = 'Score exported ✓';
};

// ============================================================
//  S2S IMPORT (Shape→Sound pattern import)
// ============================================================

var S2S_DUR_MAP = {
  '/32': 32, '/16': 16, '/8': 8, '/4': 4, '/2': 2, '/1': 1,
  '/32T': 48, '/16T': 24, '/8T': 12, '/4T': 6, '/2T': 3
};

var S2S_WAVE_VALID = {};
WAVEFORMS.forEach(function(w) { S2S_WAVE_VALID[w.id] = true; });

var s2sTargetCh = 0;
var s2sTargetIsRT = false;

function parseS2SText(text) {
  if (!text || !text.trim()) return null;
  text = text.trim();

  var bpm = null;
  var body = text;

  // Parse S2S header: "S2S|BPM:120|..."
  if (text.indexOf('S2S|') === 0) {
    var pipes = text.split('|');
    for (var i = 1; i < pipes.length - 1; i++) {
      if (pipes[i].indexOf('BPM:') === 0) {
        bpm = parseInt(pipes[i].substring(4));
        if (isNaN(bpm)) bpm = null;
      }
    }
    // Body = last pipe segment
    body = pipes[pipes.length - 1];
  }

  var entries = body.split(',');
  var steps = [];
  var warnings = [];

  for (var i = 0; i < entries.length; i++) {
    var e = entries[i].trim();
    if (!e) continue;

    var tokens = e.split(/\s+/);
    if (tokens.length < 2) {
      warnings.push('Skipped: "' + e + '"');
      continue;
    }

    var durStr = tokens[0];
    var waveStr = tokens[1];

    var dur = S2S_DUR_MAP[durStr];
    if (dur === undefined) {
      warnings.push('Unknown dur "' + durStr + '"');
      continue;
    }

    if (!S2S_WAVE_VALID[waveStr]) {
      warnings.push('Unknown wave "' + waveStr + '" → triangle');
      waveStr = 'triangle';
    }

    steps.push({ wave: waveStr, dur: dur });
  }

  if (steps.length === 0) return null;
  return { bpm: bpm, steps: steps, warnings: warnings };
}

function applyS2SToChannel(parsed, chIdx, isRT, mode) {
  var ch = isRT ? rtState[0] : state[chIdx];

  // Collect existing events if append
  var events = [];
  if (mode === 'append') {
    for (var i = 0; i < ch.count; i++) {
      if (ch.steps[i] && ch.steps[i].on) {
        events.push({ wave: ch.steps[i].wave, dur: ch.steps[i].dur });
      }
    }
  }

  // Add imported steps
  for (var i = 0; i < parsed.steps.length; i++) {
    events.push({ wave: parsed.steps[i].wave, dur: parsed.steps[i].dur });
  }

  // Clear all steps
  for (var i = 0; i < ch.steps.length; i++) {
    ch.steps[i].on = false;
    ch.steps[i].wave = 'triangle';
    ch.steps[i].dur = 16;
  }

  // Place events (same grid alignment as repackEvents + fillGaps)
  var pos = 0;
  var placed = 0;
  var dropped = 0;

  for (var e = 0; e < events.length; e++) {
    var dur = events[e].dur;
    var span = durToSteps(dur);
    var isTrip = isTripletDur(dur);
    var isNorm = isNormalDur(dur);

    // Find next aligned position
    var foundPos = -1;
    for (var p = pos; p < ch.count; p++) {
      var ok = false;
      if (isNorm && (p % 3 === 0)) ok = true;
      if (isTrip && (p % 2 === 0)) ok = true;
      if (ok && p + span <= ch.count) { foundPos = p; break; }
    }

    if (foundPos < 0) {
      // Try shorter durations
      var avail = getAvailableDurs();
      var fitted = false;
      for (var a = 0; a < avail.length; a++) {
        var trySpan = durToSteps(avail[a]);
        var tryTrip = isTripletDur(avail[a]);
        var tryNorm = isNormalDur(avail[a]);
        for (var p = pos; p < ch.count; p++) {
          var ok = false;
          if (tryNorm && (p % 3 === 0)) ok = true;
          if (tryTrip && (p % 2 === 0)) ok = true;
          if (ok && p + trySpan <= ch.count) {
            foundPos = p; dur = avail[a]; span = trySpan; fitted = true; break;
          }
        }
        if (fitted) break;
      }
      if (!fitted) { dropped++; continue; }
    }

    ch.steps[foundPos].on = true;
    ch.steps[foundPos].wave = events[e].wave;
    ch.steps[foundPos].dur = dur;
    pos = foundPos + span;
    placed++;
  }

  return { placed: placed, dropped: dropped };
}

// Modal
var s2sModal = document.getElementById('s2sModal');

function openS2SImport(chIdx, isRT) {
  s2sTargetCh = chIdx;
  s2sTargetIsRT = isRT;
  document.getElementById('s2sChName').textContent = isRT ? RT_CNAME : CNAME[chIdx];
  document.getElementById('s2sText').value = '';
  document.getElementById('s2sInfo').textContent = '';
  s2sModal.classList.add('open');
}

document.getElementById('s2sPaste').onclick = function() {
  if (navigator.clipboard && navigator.clipboard.readText) {
    navigator.clipboard.readText().then(function(text) {
      document.getElementById('s2sText').value = text;
      previewS2S(text);
    }).catch(function() {
      document.getElementById('s2sInfo').textContent = 'Clipboard denied. Paste manually.';
      document.getElementById('s2sInfo').style.color = 'var(--accent-active)';
    });
  } else {
    document.getElementById('s2sInfo').textContent = 'Clipboard API unavailable. Paste manually.';
    document.getElementById('s2sInfo').style.color = 'var(--accent-active)';
  }
};

function previewS2S(text) {
  var parsed = parseS2SText(text);
  var info = document.getElementById('s2sInfo');
  if (parsed) {
    var msg = parsed.steps.length + ' steps';
    if (parsed.bpm) msg += ' | BPM: ' + parsed.bpm;
    if (parsed.warnings.length > 0) msg += ' | ' + parsed.warnings.length + ' warnings';
    info.textContent = msg;
    info.style.color = 'var(--accent)';
  } else if (text.trim()) {
    info.textContent = 'Could not parse S2S text';
    info.style.color = 'var(--accent-active)';
  } else {
    info.textContent = '';
  }
}

document.getElementById('s2sText').addEventListener('input', function() {
  previewS2S(this.value);
});

document.getElementById('s2sCancel').onclick = function() {
  s2sModal.classList.remove('open');
};

document.getElementById('s2sApply').onclick = function() {
  var text = document.getElementById('s2sText').value;
  var parsed = parseS2SText(text);
  if (!parsed) {
    document.getElementById('s2sInfo').textContent = 'Nothing to import.';
    document.getElementById('s2sInfo').style.color = 'var(--accent-active)';
    return;
  }

  // BPM sync
  if (parsed.bpm && parsed.bpm !== getBPM()) {
    if (confirm('S2S BPM (' + parsed.bpm + ') \u2260 Maestro BPM (' + getBPM() + ').\n\nApply S2S BPM?')) {
      document.getElementById('bpm').value = parsed.bpm;
    }
  }

  var mode = document.getElementById('s2sMode').value;
  var result = applyS2SToChannel(parsed, s2sTargetCh, s2sTargetIsRT, mode);

  // Rebuild
  if (s2sTargetIsRT) {
    renderRTGrid();
    renderRTEventChain();
    buildRTUI();
  } else {
    renderSplitGrid();
    for (var rc = 0; rc < 3; rc++) renderEventChain(rc);
    buildUI();
  }

  s2sModal.classList.remove('open');

  var chName = s2sTargetIsRT ? RT_CNAME : CNAME[s2sTargetCh];
  var msg = 'S2S → ' + chName + ': ' + result.placed + ' steps';
  if (result.dropped > 0) msg += ' (' + result.dropped + ' dropped)';
  document.getElementById('status').textContent = msg;
}

s2sModal.addEventListener('click', function(e) {
  if (e.target === s2sModal) s2sModal.classList.remove('open');
});

// ============================================================
//  16-STEP SCORE VIEW (for Oxi One MK2 etc.)
// ============================================================
function generate16Score() {
  var lines = [];
  var q = getQuant();
  var bpm = getBPM();

  lines.push('==============================================');
  lines.push('  16-STEP SCORE — ' + bpm + ' BPM');
  lines.push('  Normal lane: 1 cell = 3 ticks (16 cells = 48 ticks)');
  lines.push('  Triplet lane: 1 cell = 2 ticks (16 cells = 32 ticks)');
  lines.push('==============================================');
  lines.push('');

  var usedPatIdx = [];
  var usedSet = {};
  for (var s = 0; s < song.length; s++) {
    var idx = song[s].patIdx;
    if (!usedSet[idx]) { usedSet[idx] = true; usedPatIdx.push(idx); }
  }
  if (!usedSet[currentPatternIdx]) usedPatIdx.push(currentPatternIdx);

  for (var pi = 0; pi < usedPatIdx.length; pi++) {
    var pat = patterns[usedPatIdx[pi]];
    if (!pat) continue;
    var channels = pat.channels;
    var patLen = pat.patternLength || 128;

    lines.push('----------------------------------------------');
    lines.push('  Pattern ' + pat.name + ' (' + patLen + ' ticks)');
    lines.push('----------------------------------------------');

    for (var c = 0; c < 3; c++) {
      var ch = channels[c];
      var blocked = computeBlocked(ch);
      lines.push('');
      lines.push('  CH' + (c + 1) + ' — Normal lane (3 tick/cell):');

      // Normal lane: cells at every 3 ticks
      var nCells = Math.ceil(patLen / 3);
      for (var row = 0; row < nCells; row += 16) {
        var rowLabel = ('   ' + (row + 1)).slice(-3) + '-' + ('   ' + Math.min(row + 16, nCells)).slice(-3) + ' |';
        var cells = [];
        for (var ci = row; ci < row + 16 && ci < nCells; ci++) {
          var tick = ci * 3;
          if (tick >= patLen) { cells.push(' . '); continue; }
          var step = ch.steps[tick];
          if (step && step.on) {
            var sym = (WAVE_SYM[step.wave] || '?');
            var dl = durLabel(step.dur).replace('/', '');
            cells.push(sym + dl);
          } else if (blocked[tick]) {
            cells.push(' - ');
          } else {
            cells.push(' . ');
          }
        }
        lines.push('  ' + rowLabel + cells.join('|') + '|');
      }

      lines.push('  CH' + (c + 1) + ' — Triplet lane (2 tick/cell):');
      var tCells = Math.ceil(patLen / 2);
      for (var row = 0; row < tCells; row += 16) {
        var rowLabel = ('   ' + (row + 1)).slice(-3) + '-' + ('   ' + Math.min(row + 16, tCells)).slice(-3) + ' |';
        var cells = [];
        for (var ci = row; ci < row + 16 && ci < tCells; ci++) {
          var tick = ci * 2;
          if (tick >= patLen) { cells.push(' . '); continue; }
          var step = ch.steps[tick];
          if (step && step.on) {
            var sym = (WAVE_SYM[step.wave] || '?');
            var dl = durLabel(step.dur).replace('/', '');
            cells.push(sym + dl);
          } else if (blocked[tick]) {
            cells.push(' - ');
          } else {
            cells.push(' . ');
          }
        }
        lines.push('  ' + rowLabel + cells.join('|') + '|');
      }
    }
    lines.push('');
  }

  // RT patterns
  lines.push('============ RT PATTERNS ============');
  for (var pi = 0; pi < rtPatterns.length; pi++) {
    var rtPat = rtPatterns[pi];
    var rtCh = rtPat.channels[0];
    var rtPatLen = rtPat.patternLength || rtCh.count;
    var blocked = computeBlocked(rtCh);

    lines.push('  RT Pattern ' + rtPat.name + ' (' + rtPatLen + ' ticks)');
    lines.push('  RT — Normal lane (3 tick/cell):');
    var nCells = Math.ceil(rtPatLen / 3);
    for (var row = 0; row < nCells; row += 16) {
      var rowLabel = ('   ' + (row + 1)).slice(-3) + '-' + ('   ' + Math.min(row + 16, nCells)).slice(-3) + ' |';
      var cells = [];
      for (var ci = row; ci < row + 16 && ci < nCells; ci++) {
        var tick = ci * 3;
        if (tick >= rtPatLen) { cells.push(' . '); continue; }
        var step = rtCh.steps[tick];
        if (step && step.on) { cells.push((WAVE_SYM[step.wave] || '?') + durLabel(step.dur).replace('/', '')); }
        else if (blocked[tick]) { cells.push(' - '); }
        else { cells.push(' . '); }
      }
      lines.push('  ' + rowLabel + cells.join('|') + '|');
    }
    lines.push('  RT — Triplet lane (2 tick/cell):');
    var tCells = Math.ceil(rtPatLen / 2);
    for (var row = 0; row < tCells; row += 16) {
      var rowLabel = ('   ' + (row + 1)).slice(-3) + '-' + ('   ' + Math.min(row + 16, tCells)).slice(-3) + ' |';
      var cells = [];
      for (var ci = row; ci < row + 16 && ci < tCells; ci++) {
        var tick = ci * 2;
        if (tick >= rtPatLen) { cells.push(' . '); continue; }
        var step = rtCh.steps[tick];
        if (step && step.on) { cells.push((WAVE_SYM[step.wave] || '?') + durLabel(step.dur).replace('/', '')); }
        else if (blocked[tick]) { cells.push(' - '); }
        else { cells.push(' . '); }
      }
      lines.push('  ' + rowLabel + cells.join('|') + '|');
    }
    lines.push('');
  }

  lines.push('==============================================');
  lines.push('Legend: . = empty, - = blocked (duration span)');
  lines.push('Wave symbols: ' + Object.keys(WAVE_SYM).map(function(k) { return WAVE_SYM[k] + '=' + k; }).join(', '));
  return lines.join('\n');
}

document.getElementById('btn16Score').onclick = function() {
  var text = generate16Score();
  // Show in a modal overlay
  var overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(0,0,0,0.8);z-index:9999;display:flex;align-items:center;justify-content:center;';
  var box = document.createElement('div');
  box.style.cssText = 'background:#1a1a2e;color:#e0e0e0;padding:20px;border-radius:10px;max-width:90vw;max-height:85vh;overflow:auto;font-family:monospace;font-size:12px;white-space:pre;line-height:1.4;';
  box.textContent = text;
  var closeBtn = document.createElement('button');
  closeBtn.textContent = 'CLOSE';
  closeBtn.style.cssText = 'position:fixed;top:20px;right:20px;z-index:10000;padding:8px 16px;background:#f80;color:#000;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';
  var dlBtn = document.createElement('button');
  dlBtn.textContent = 'DOWNLOAD';
  dlBtn.style.cssText = 'position:fixed;top:20px;right:100px;z-index:10000;padding:8px 16px;background:#2dd4bf;color:#000;border:none;border-radius:5px;cursor:pointer;font-weight:bold;';
  dlBtn.onclick = function() {
    var blob = new Blob([text], { type: 'text/plain; charset=utf-8' });
    var a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = '16step_score_' + getBPM() + 'bpm.txt';
    a.click();
  };
  closeBtn.onclick = function() { document.body.removeChild(overlay); document.body.removeChild(closeBtn); document.body.removeChild(dlBtn); };
  overlay.onclick = function(e) { if (e.target === overlay) closeBtn.onclick(); };
  overlay.appendChild(box);
  document.body.appendChild(overlay);
  document.body.appendChild(closeBtn);
  document.body.appendChild(dlBtn);
};

// ============================================================
//  AUDIO EXPORT — Offline rendering
// ============================================================

// Render a single pattern's channels to a stereo AudioBuffer
function renderPatternOffline(channels, sampleRate, callback, patLen) {
  var q = getQuant();
  var bpm = getBPM();
  var secPerStep = (60 / bpm) / (q / 4);
  var maxCount = patLen || Math.max(channels[0].count, channels[1].count, channels[2].count);
  var totalSec = maxCount * secPerStep + 0.5;
  var totalFrames = Math.ceil(sampleRate * totalSec);
  if (totalFrames < 1) { callback(null); return; }

  var chBuffers = [];
  // Back channels (0-2)
  for (var c = 0; c < 3; c++) {
    var chBuf = new Float32Array(totalFrames);
    var ch = channels[c];
    for (var s = 0; s < ch.count; s++) {
      var step = ch.steps[s];
      if (!step || !step.on) continue;
      if (step.wave === 'low' && !ch.bipolar) continue;
      var durSteps = q / step.dur;
      var durSec = durSteps * secPerStep;
      durSec = Math.min(durSec, 4.0);
      if (durSec < 0.005) continue;
      var startSample = Math.round(s * secPerStep * sampleRate);
      var noteLen = Math.ceil(sampleRate * durSec);
      var fadeLen = Math.max(Math.ceil(sampleRate * 0.003), Math.ceil(noteLen * 0.03));
      for (var i = 0; i < noteLen; i++) {
        var idx = startSample + i;
        if (idx >= totalFrames) break;
        var lfoT = i / noteLen;
        var lfo = getLFOValue(step.wave, ch.smooth, lfoT);
        if (ch.bipolar) lfo = lfo * 2 - 1;
        var audio = getChAudio(c, channels);
        var carrier = Math.sin(2 * Math.PI * audio.freq * i / sampleRate);
        var fade = 1;
        if (i > noteLen - fadeLen) fade = (noteLen - i) / fadeLen;
        chBuf[idx] += carrier * lfo * audio.volume * fade;
      }
    }
    var audioP = getChAudio(c, channels);
    chBuffers.push({ data: chBuf, pan: (audioP.pan || 0) / 100 });
  }

  // RT channel (mix into same buffer)
  var rtCh = rtState[0];
  if (rtCh && rtCh.count > 0) {
    var rtBuf = new Float32Array(totalFrames);
    for (var s = 0; s < rtCh.count; s++) {
      var step = rtCh.steps[s];
      if (!step || !step.on) continue;
      if (step.wave === 'low' && !rtCh.bipolar) continue;
      var durSteps = q / step.dur;
      var durSec = durSteps * secPerStep;
      durSec = Math.min(durSec, 4.0);
      if (durSec < 0.005) continue;
      var startSample = Math.round(s * secPerStep * sampleRate);
      var noteLen = Math.ceil(sampleRate * durSec);
      var fadeLen = Math.max(Math.ceil(sampleRate * 0.003), Math.ceil(noteLen * 0.03));
      for (var i = 0; i < noteLen; i++) {
        var idx = startSample + i;
        if (idx >= totalFrames) break;
        var lfoT = i / noteLen;
        var lfo = getLFOValue(step.wave, rtCh.smooth, lfoT);
        if (rtCh.bipolar) lfo = lfo * 2 - 1;
        var rtAudio = getRTAudio();
        var carrier = Math.sin(2 * Math.PI * rtAudio.freq * i / sampleRate);
        var fade = 1;
        if (i > noteLen - fadeLen) fade = (noteLen - i) / fadeLen;
        rtBuf[idx] += carrier * lfo * rtAudio.volume * fade;
      }
    }
    chBuffers.push({ data: rtBuf, pan: (getRTAudio().pan || 0) / 100 });
  }

  // Mix to stereo with pan
  var left = new Float32Array(totalFrames);
  var right = new Float32Array(totalFrames);
  for (var c = 0; c < chBuffers.length; c++) {
    var pan = chBuffers[c].pan;
    var gainL = Math.cos((pan + 1) * Math.PI / 4);
    var gainR = Math.sin((pan + 1) * Math.PI / 4);
    var d = chBuffers[c].data;
    for (var i = 0; i < totalFrames; i++) {
      left[i] += d[i] * gainL;
      right[i] += d[i] * gainR;
    }
  }

  // Clamp
  for (var i = 0; i < totalFrames; i++) {
    if (left[i] > 1) left[i] = 1; if (left[i] < -1) left[i] = -1;
    if (right[i] > 1) right[i] = 1; if (right[i] < -1) right[i] = -1;
  }

  callback({ left: left, right: right, sampleRate: sampleRate, length: totalFrames });
}

// Render full song (all patterns with repeats) to stereo buffer
function renderSongOffline(sampleRate, callback) {
  var q = getQuant();
  var bpm = getBPM();
  var secPerStep = (60 / bpm) / (q / 4);

  // Calculate total frames from BACK song
  var segments = [];
  var totalFrames = 0;
  for (var s = 0; s < song.length; s++) {
    var entry = song[s];
    var pat = patterns[entry.patIdx];
    if (!pat) continue;
    var segLen = pat.patternLength || Math.max(pat.channels[0].count, pat.channels[1].count, pat.channels[2].count);
    var segFrames = Math.ceil(segLen * secPerStep * sampleRate) * entry.repeat;
    segments.push({ pat: pat, repeat: entry.repeat, maxCount: segLen, frames: segFrames });
    totalFrames += segFrames;
  }
  totalFrames += Math.ceil(0.5 * sampleRate); // tail

  if (totalFrames < 1) { callback(null); return; }

  var left = new Float32Array(totalFrames);
  var right = new Float32Array(totalFrames);
  var offset = 0;

  // Render BACK channels
  for (var si = 0; si < segments.length; si++) {
    var seg = segments[si];
    for (var rep = 0; rep < seg.repeat; rep++) {
      var repOffset = offset;
      for (var c = 0; c < 3; c++) {
        var ch = seg.pat.channels[c];
        var audioS = getChAudio(c, seg.pat.channels);
        var pan = (audioS.pan || 0) / 100;
        var gainL = Math.cos((pan + 1) * Math.PI / 4);
        var gainR = Math.sin((pan + 1) * Math.PI / 4);
        for (var st = 0; st < ch.count; st++) {
          var step = ch.steps[st];
          if (!step || !step.on) continue;
          if (step.wave === 'low' && !ch.bipolar) continue;
          var durSteps = q / step.dur;
          var durSec = durSteps * secPerStep;
          durSec = Math.min(durSec, 4.0);
          if (durSec < 0.005) continue;
          var startSample = repOffset + Math.round(st * secPerStep * sampleRate);
          var noteLen = Math.ceil(sampleRate * durSec);
          var fadeLen = Math.max(Math.ceil(sampleRate * 0.003), Math.ceil(noteLen * 0.03));
          for (var i = 0; i < noteLen; i++) {
            var idx = startSample + i;
            if (idx >= totalFrames) break;
            var lfoT = i / noteLen;
            var lfo = getLFOValue(step.wave, ch.smooth, lfoT);
            if (ch.bipolar) lfo = lfo * 2 - 1;
            var carrier = Math.sin(2 * Math.PI * audioS.freq * i / sampleRate);
            var fade = 1;
            if (i > noteLen - fadeLen) fade = (noteLen - i) / fadeLen;
            var sample = carrier * lfo * audioS.volume * fade;
            left[idx] += sample * gainL;
            right[idx] += sample * gainR;
          }
        }
      }
      offset += Math.ceil(seg.maxCount * secPerStep * sampleRate);
    }
  }

  // Render RT channels (parallel song, mixed into same buffer)
  var rtOffset = 0;
  for (var si = 0; si < rtSong.length; si++) {
    var rtEntry = rtSong[si];
    var rtPat = rtPatterns[rtEntry.patIdx];
    if (!rtPat) continue;
    var rtCh = rtPat.channels[0];
    var rtPatLen = rtPat.patternLength || rtCh.count;
    var rtAudio = getRTAudio(rtPat.channels);
    var rtPan = (rtAudio.pan || 0) / 100;
    var rtGainL = Math.cos((rtPan + 1) * Math.PI / 4);
    var rtGainR = Math.sin((rtPan + 1) * Math.PI / 4);

    for (var rep = 0; rep < rtEntry.repeat; rep++) {
      var repOffset = rtOffset;
      for (var st = 0; st < rtCh.count; st++) {
        var step = rtCh.steps[st];
        if (!step || !step.on) continue;
        if (step.wave === 'low' && !rtCh.bipolar) continue;
        var durSteps = q / step.dur;
        var durSec = durSteps * secPerStep;
        durSec = Math.min(durSec, 4.0);
        if (durSec < 0.005) continue;
        var startSample = repOffset + Math.round(st * secPerStep * sampleRate);
        var noteLen = Math.ceil(sampleRate * durSec);
        var fadeLen = Math.max(Math.ceil(sampleRate * 0.003), Math.ceil(noteLen * 0.03));
        for (var i = 0; i < noteLen; i++) {
          var idx = startSample + i;
          if (idx >= totalFrames) break;
          var lfoT = i / noteLen;
          var lfo = getLFOValue(step.wave, rtCh.smooth, lfoT);
          if (rtCh.bipolar) lfo = lfo * 2 - 1;
          var carrier = Math.sin(2 * Math.PI * rtAudio.freq * i / sampleRate);
          var fade = 1;
          if (i > noteLen - fadeLen) fade = (noteLen - i) / fadeLen;
          var sample = carrier * lfo * rtAudio.volume * fade;
          left[idx] += sample * rtGainL;
          right[idx] += sample * rtGainR;
        }
      }
      rtOffset += Math.ceil(rtPatLen * secPerStep * sampleRate);
    }
  }

  // Clamp
  for (var i = 0; i < totalFrames; i++) {
    if (left[i] > 1) left[i] = 1; if (left[i] < -1) left[i] = -1;
    if (right[i] > 1) right[i] = 1; if (right[i] < -1) right[i] = -1;
  }

  callback({ left: left, right: right, sampleRate: sampleRate, length: totalFrames });
}

// ============================================================
//  AUDIO EXPORT — WAV encoder
// ============================================================
function encodeWav(stereoData) {
  var sr = stereoData.sampleRate;
  var len = stereoData.length;
  var numChannels = 2;
  var bitsPerSample = 16;
  var byteRate = sr * numChannels * bitsPerSample / 8;
  var blockAlign = numChannels * bitsPerSample / 8;
  var dataSize = len * numChannels * (bitsPerSample / 8);
  var buffer = new ArrayBuffer(44 + dataSize);
  var view = new DataView(buffer);

  // WAV header
  writeString(view, 0, 'RIFF');
  view.setUint32(4, 36 + dataSize, true);
  writeString(view, 8, 'WAVE');
  writeString(view, 12, 'fmt ');
  view.setUint32(16, 16, true);           // chunk size
  view.setUint16(20, 1, true);            // PCM
  view.setUint16(22, numChannels, true);
  view.setUint32(24, sr, true);
  view.setUint32(28, byteRate, true);
  view.setUint16(32, blockAlign, true);
  view.setUint16(34, bitsPerSample, true);
  writeString(view, 36, 'data');
  view.setUint32(40, dataSize, true);

  // Interleave L/R samples as 16-bit PCM
  var offset = 44;
  for (var i = 0; i < len; i++) {
    var sL = Math.max(-1, Math.min(1, stereoData.left[i]));
    var sR = Math.max(-1, Math.min(1, stereoData.right[i]));
    view.setInt16(offset, sL < 0 ? sL * 0x8000 : sL * 0x7FFF, true);
    offset += 2;
    view.setInt16(offset, sR < 0 ? sR * 0x8000 : sR * 0x7FFF, true);
    offset += 2;
  }

  return new Blob([buffer], { type: 'audio/wav' });
}

function writeString(view, offset, string) {
  for (var i = 0; i < string.length; i++) {
    view.setUint8(offset + i, string.charCodeAt(i));
  }
}

// ============================================================
//  AUDIO EXPORT — MP3 encoder (lamejs)
// ============================================================
function encodeMp3(stereoData) {
  if (typeof lamejs === 'undefined' || !lamejs.Mp3Encoder) {
    alert('MP3 encoder (lamejs) not loaded. Check internet connection.');
    return null;
  }
  var sr = stereoData.sampleRate;
  var len = stereoData.length;
  var mp3encoder = new lamejs.Mp3Encoder(2, sr, 320);
  var blockSize = 1152;
  var mp3Data = [];

  // Convert Float32 to Int16
  var leftI16 = new Int16Array(len);
  var rightI16 = new Int16Array(len);
  for (var i = 0; i < len; i++) {
    var sL = Math.max(-1, Math.min(1, stereoData.left[i]));
    var sR = Math.max(-1, Math.min(1, stereoData.right[i]));
    leftI16[i] = sL < 0 ? sL * 0x8000 : sL * 0x7FFF;
    rightI16[i] = sR < 0 ? sR * 0x8000 : sR * 0x7FFF;
  }

  for (var i = 0; i < len; i += blockSize) {
    var end = Math.min(i + blockSize, len);
    var leftChunk = leftI16.subarray(i, end);
    var rightChunk = rightI16.subarray(i, end);
    var mp3buf = mp3encoder.encodeBuffer(leftChunk, rightChunk);
    if (mp3buf.length > 0) mp3Data.push(mp3buf);
  }

  var flush = mp3encoder.flush();
  if (flush.length > 0) mp3Data.push(flush);

  return new Blob(mp3Data, { type: 'audio/mp3' });
}

// ============================================================
//  AUDIO EXPORT — Button handlers
// ============================================================
function downloadBlob(blob, filename) {
  var a = document.createElement('a');
  a.href = URL.createObjectURL(blob);
  a.download = filename;
  a.click();
  setTimeout(function() { URL.revokeObjectURL(a.href); }, 5000);
}

document.getElementById('btnWav').onclick = function(e) {
  var statusEl = document.getElementById('status');
  var isSong = e.shiftKey;

  statusEl.textContent = 'Rendering ' + (isSong ? 'song' : 'pattern') + ' to WAV...';

  setTimeout(function() {
    var curPatLen = patterns[currentPatternIdx].patternLength || 128;
    var renderFn = isSong ? function(cb) { renderSongOffline(44100, cb); }
                          : function(cb) { renderPatternOffline(state, 44100, cb, curPatLen); };
    renderFn(function(stereoData) {
      if (!stereoData) {
        statusEl.textContent = 'Nothing to render';
        return;
      }
      var blob = encodeWav(stereoData);
      var prefix = isSong ? 'song' : 'pat_' + patterns[currentPatternIdx].name;
      downloadBlob(blob, prefix + '_' + getBPM() + 'bpm.wav');
      var durSec = (stereoData.length / stereoData.sampleRate).toFixed(1);
      statusEl.textContent = 'WAV exported ✓ (' + durSec + 's, ' + (blob.size / 1024).toFixed(0) + 'KB)';
    });
  }, 50);
};

document.getElementById('btnMp3').onclick = function(e) {
  var statusEl = document.getElementById('status');
  var isSong = e.shiftKey;

  if (typeof lamejs === 'undefined') {
    statusEl.textContent = 'Loading MP3 encoder...';
    var script = document.createElement('script');
    script.src = 'https://cdn.jsdelivr.net/npm/lamejs@1.2.1/lame.min.js';
    script.onload = function() { document.getElementById('btnMp3').click(); };
    script.onerror = function() { statusEl.textContent = 'Failed to load MP3 encoder'; };
    document.head.appendChild(script);
    return;
  }

  statusEl.textContent = 'Rendering ' + (isSong ? 'song' : 'pattern') + ' to MP3...';

  setTimeout(function() {
    var curPatLen = patterns[currentPatternIdx].patternLength || 128;
    var renderFn = isSong ? function(cb) { renderSongOffline(44100, cb); }
                          : function(cb) { renderPatternOffline(state, 44100, cb, curPatLen); };
    renderFn(function(stereoData) {
      if (!stereoData) {
        statusEl.textContent = 'Nothing to render';
        return;
      }
      var blob = encodeMp3(stereoData);
      if (!blob) return;
      var prefix = isSong ? 'song' : 'pat_' + patterns[currentPatternIdx].name;
      downloadBlob(blob, prefix + '_' + getBPM() + 'bpm.mp3');
      var durSec = (stereoData.length / stereoData.sampleRate).toFixed(1);
      statusEl.textContent = 'MP3 exported ✓ (' + durSec + 's, ' + (blob.size / 1024).toFixed(0) + 'KB)';
    });
  }, 50);
};

// ============================================================
//  INIT
// ============================================================
applyTheme(currentTheme);
buildUI();
buildRTUI();
renderRTSongLane();

// Click empty area in song section → deselect all song cells
document.querySelector('.song-section').addEventListener('click', function(e) {
  if (e.target.closest('.song-cell') || e.target.closest('.song-add') || e.target.closest('.pool-cell') || e.target.closest('.pattern-pool')) return;
  selectedSongCell = -1;
  selectedRTSongCell = -1;
  renderSongLane();
  renderRTSongLane();
});
</script>
</body>
</html>
